<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM内存</title>
      <link href="/2024/04/21/JVM%E5%86%85%E5%AD%98/"/>
      <url>/2024/04/21/JVM%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h1><h3 id="JVM的内存区域模型"><a href="#JVM的内存区域模型" class="headerlink" title="JVM的内存区域模型"></a>JVM的内存区域模型</h3><p><img src="/.io//Untitled.png" alt="Untitled"></p><p><strong>方法区和堆是线程共享区，虚拟机栈、程序计数器和本地方法栈是线程私有的。</strong></p><ul><li><p><strong>方法区</strong></p><p>  也称为永久代，非堆，用于存储虚拟机加载的类信息，常量，静态变量，是各个线程<strong>共享的内存区域。</strong></p><p>  运行时常量池：作为方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项关键信息就是常量池，用于存放编译器生成的各种符号的引用，这部分将在类加载后放到方法区的运行时常量池中。</p></li><li><p><strong>虚拟机栈</strong></p><p>  描述的是Java方法执行的内存模型，每个方法被执行的时候，都会创建一个<strong>栈帧</strong>用于存储局部变量，操作栈，方法出口等信息。每个<strong>方法</strong>被调用到执行完成的过程，就对应着一个<strong>栈帧</strong>在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。</p><p>  局部变量表：存放八种基本类型，对象引用，其中64位的long和double类型的数据会占用两个局部变量的空间。局部变量表是在编译时完成分配的，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，而且在运行的时候不会被改变。</p><p>  <img src="/.io//Untitled%201.png" alt="Untitled"></p></li><li><p><strong>本地方法栈</strong></p><p>  与虚拟机栈类似，为本地方法服务，为虚拟机使用到本地(Native)方法服务的。</p></li><li><p><strong>堆</strong></p><p>  java堆，GC堆。是JVM管理的内存中<strong>最大</strong>的一块内存区域，是线程共享的，随着JVM的启动创建。存放了对象的实例以及数组。</p><p>  <img src="/.io//Untitled%202.png" alt="Untitled"></p><p>  Permanent  Generation(方法区) 用来存放JVM自己的反射对象：类对象，方法对象等。</p><p>  如图可知JVM内存分为两大块，<strong>OLD</strong>(老年代)与<strong>NEW</strong>(新生代)；</p><p>  OLD用来存放应用程序中生命周期长的对象。</p><p>  NEW(新生代)分为Eden，From和To三个模块(8:1:1)。Eden(伊甸园)的空间，主要用来存放新生的对象，剩下的两个模块<strong>来源空间</strong>与<strong>目标空间</strong>用来存放每次垃圾回收后存活下来的对象。</p></li><li><p><strong>程序计数器</strong></p><p>  最小的一块内存，作用是当前线程所执行的字节码的型号指示器，在虚拟机的模型里面。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环。异常处理，线程恢复等基础功能都需要依赖计数器完成。</p></li><li><p><strong>直接内存</strong></p><p>  直接内存并不是虚拟机内存第一部分，也不是JVM规范中定义的内存区域。是本机内存。</p></li></ul><p><strong>堆与栈的区别</strong></p><p>堆线程共享，生命周期不由单个方法调用决定，可以在方法调用结束后继续存在。直到不被任何变量引用，然后被垃圾回收器回收。</p><p>栈线程私有，通常随着方法调用的结束而消失，无需进行垃圾收集。</p><h3 id="JDK1-6、1-7、1-8的内存区域变化"><a href="#JDK1-6、1-7、1-8的内存区域变化" class="headerlink" title="JDK1.6、1.7、1.8的内存区域变化"></a>JDK1.6、1.7、1.8的内存区域变化</h3><p>主要是体现在方法区的实现：</p><ul><li><p><strong>JDK1.6使用永久代实现方法区</strong></p><p>  <img src="/.io//Untitled%203.png" alt="Untitled"></p></li><li><p><strong>JDK1.7将字符串常量池、静态变量存放在堆上。</strong></p><p>  <img src="/.io//Untitled%204.png" alt="Untitled"></p></li><li><p><strong>JDK1.8取消永久代</strong></p><p>  在直接内存中划分出一块区域作为<strong>元空间</strong>，运行时常量池、类常量池都移动到元空间。</p><p>  <img src="/.io//Untitled%205.png" alt="Untitled"></p></li></ul><p><strong>为什么使用元空间替代永久代作为方法区实现</strong></p><p>Java虚拟机规范规定的 方法区只是换种方式实现。</p><ul><li>使用永久代来实现方法区的决定的设计导致Java应用更容易遇到内存溢出问题。因为永久代有上限，即使不设置也有默认大小。而J9和JRockit只要没有触碰到进程可用内存的上限，比如32位系统中的4GB限制，就不会出现问题，而极少数方法(Stirng::intern())会因永久代的原因导致不同虚拟机下有不同的表现。</li><li>主观上当 Oracle 收购 BEA 获得了 JRockit 的所有权后，准备把 JRockit 中的优秀功能，譬如 Java Mission Control 管理工具，移植到 HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到 HotSpot 未来的发展，在 JDK 6 的 时候 HotSpot 开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了 JDK 7 的 HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Meta-space）来代替，把 JDK 7 中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</li></ul><h3 id="什么是指针碰撞？什么是空闲列表？"><a href="#什么是指针碰撞？什么是空闲列表？" class="headerlink" title="什么是指针碰撞？什么是空闲列表？"></a><strong>什么是指针碰撞？什么是空闲列表？</strong></h3><p>内存分配有两种方式，<strong>指针碰撞</strong>（Bump The Pointer）、<strong>空闲列表</strong>（Free List）。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-10.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-10.png"></p><p><strong>指针碰撞和空闲列表</strong></p><ul><li><strong>指针碰撞</strong>：假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</li><li><strong>空闲列表</strong>：如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。</li></ul><p>两种方式的选择由 Java 堆是否<strong>规整</strong>决定，Java 堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的</p><h3 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h3><p><strong>内存泄露</strong>就是申请的内存空间没有被正确释放，导致内存被白白占用。</p><p><strong>内存溢出</strong>就是申请的内存超过了可用内存，内存不够了。</p><p>两者关系：内存泄露可能会导致内存溢出。</p><p>用一个有味道的比喻，内存溢出就是排队去蹲坑，发现没坑位了，内存泄漏，就是有人<strong>占着茅坑不拉屎</strong>，占着茅坑不拉屎的多了可能会导致坑位不够用</p><p><strong>创造几个内存溢出</strong></p><ul><li><p><strong>Java堆溢出</strong></p><p>  Java堆用于存储对象实例，只要不断创建不可回收的对象，比如静态对象，就可以造成OOM。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数： -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">OOMObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>虚拟机栈OOM</strong></p><p>  HotSPot的虚拟机的栈内存大小是固定的，可以不断创建线程，因为操作系统给每个进程分配的内存是有限的。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vm参数：-Xss2M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaVMStackOOM</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dontStop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stackLeakByThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">JavaVMStackOOM</span> <span class="variable">oom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaVMStackOOM</span>();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><strong>内存泄漏的原因</strong></p><p><img src="/.io//Untitled%206.png" alt="Untitled"></p><ul><li><p><strong>静态集合的内存泄漏</strong></p><p>  生命周期和JVM一致，所以引用了对象就不能释放。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOM</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oomTests</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">   list.add(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>单例模式</strong></p><p>  和上述例子类似，单例对象在初始化后以静态变量的方式在JVM的整个生命周期中还存在，如果单例对象持有外部的引用，那么这个外部的对象就不会被GC回收。</p></li><li><p><strong>数据连接、IO、Socket等连接</strong></p><p>  创建的连接不再使用时，要用close方法关闭连接。只有连接被关闭后，GC才会回收对应的对象(Connection,Statement,ResultSet,Session)。忘记关闭这些资源会导致持续占有内存，无法被GC回收。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    conn = DriverManager.getConnection(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//不关闭连接</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>变量不合理的作用域</strong></p><p>  一个变量的定义作用域大于其适用范围，很可能造成内存泄漏。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line">Object object;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">object = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">//...其他代码</span></span><br><span class="line"><span class="comment">//由于作用域原因，method1执行完成之后，object 对象所分配的内存不会马上释放</span></span><br><span class="line">object = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>hash值发生变化</strong></p><p>  hash值发生变化，无法找到存入的对象了，这也是为什么String类型被设置成了不可变类型。</p></li><li><p><strong>ThreadLocal使用不当</strong></p><p>  <strong>弱引用，要记得remove。</strong></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM的垃圾收集</title>
      <link href="/2024/04/21/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
      <url>/2024/04/21/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM的垃圾收集"><a href="#JVM的垃圾收集" class="headerlink" title="JVM的垃圾收集"></a>JVM的垃圾收集</h1><p><img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled.png" alt="Untitled"></p><p><strong>回收（GC）</strong>，顾名思义就是释放垃圾占用的空间，防止内存爆掉。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。</p><p>那在回收的时候，要弄清楚什么是垃圾、什么不是垃圾，这样就需要一种<strong>垃圾判断算法</strong>。</p><ul><li><p><strong>引用计数法</strong></p><p>  通过在对象头中分配一个空间来保存该对象被引用的次数。</p></li><li><p><strong>可达性分析法</strong></p><p>  通过一些被称为<strong>引用链</strong>(GC Roots)的对象作为起点，然后向下搜索，搜索走过的路径被称为Reference Chain，当一个对象到引用链之间没有任何引用相连时，即从引用链到该对象节点不可达，说明这个对象是需要垃圾收集的。</p><p>  <img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%201.png" alt="Untitled"></p></li></ul><p><strong>垃圾判断之后就是垃圾收集算法</strong></p><ul><li><p><strong>复制算法</strong></p><p>  使用复制算法，在进行垃圾回收的时候，回收器将存活对象从来源空间复制到目标空间，形成所有存活对象紧密排布的对列，分布在目标空间的一端，然后进行互换。</p><p>  <img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%202.png" alt="Untitled"></p><p>  实现：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">collect() &#123;</span><br><span class="line"><span class="comment">// 变量前面加*表示指针</span></span><br><span class="line"><span class="comment">// free指向TOSPACE半区的起始位置</span></span><br><span class="line">*free = *to_start;</span><br><span class="line"><span class="keyword">for</span>(root in Roots) &#123;</span><br><span class="line">copy(*free, root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换FROMSPACE和TOSPACE</span></span><br><span class="line">swap(*from_start,*to_start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  核心函数copy的实现：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">copy(*free,obj) &#123;</span><br><span class="line"><span class="comment">// 检查obj是否已经复制完成</span></span><br><span class="line"><span class="comment">// 这里的tag仅是一个逻辑上的域</span></span><br><span class="line"><span class="keyword">if</span>(obj.tag != COPIED) &#123;</span><br><span class="line"><span class="comment">// 将obj真正的复制到free指向的空间</span></span><br><span class="line">copy_data(*free,obj);</span><br><span class="line"><span class="comment">// 给obj.tag贴上COPIED这个标签</span></span><br><span class="line"><span class="comment">// 即使有多个指向obj的指针，obj也不会被复制多次</span></span><br><span class="line">obj.tag = COPIED;</span><br><span class="line"><span class="comment">// 复制完成后把对象的新地址存放在老对象的forwarding域中</span></span><br><span class="line">obj.forwarding = *free;</span><br><span class="line"><span class="comment">// 按照obj的长度将free指针向前移动</span></span><br><span class="line">*free += obj.size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归调用copy函数复制其关联的子对象</span></span><br><span class="line"><span class="keyword">for</span>(child <span class="title function_">ingetRefNode</span><span class="params">(obj.forwarding)</span>)&#123;</span><br><span class="line">*child = copy(*free,child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">returnobj.forwarding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这段代码中需要注意两个问题，其一是 tag&#x3D;COPIED 只是一个逻辑上的概念，用来区分对象是否已经完成复制，以确保即使这个对象被多次引用，也仅会复制一次；另外一个问题则是 forwarding 域， forwarding指针 在前面已经多次提到过，主要是用来保存对象移动后的新地址，比如在标记整理算法中，对象移动后需要遍历更新对象的引用关系，就需要使用 forwarding指针 来查找其移动后的地址，而在复制算法中，其作用类似，如果遇到已复制完成的对象，直接通过forwarding域把对象的新地址返回即可。整个复制算法的基本致流程如下图所示。</p><p>  <img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%203.png" alt="Untitled"></p><p>  调用根节点找到对象B</p><p>  <img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%204.png" alt="Untitled"></p><p>  B被复制后在目标空间中生成了B‘，B中的tag已经打上了COPIED的标签，forwarding指针中也存放了B’的地址。之后会对B引用的对象进行复制，复制结束后继续下一个根节点，直到全部复制。</p><p>  最后把FROM和TO进行互换，GC就结束了</p><p>  <img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%205.png" alt="Untitled"></p><p>  程序的搜索顺序是按照B、A、E进行搜索的，那就是说利用了深度优先算法。</p><p>  复制算法主要有如下优势：</p><ul><li><strong>吞吐量高</strong>：整个GC算法只搜索并复制存活对象，尤其是堆越大，差距越明显，毕竟它消耗的时间只是与活动对象数量成正比。</li><li><strong>可实现高速分配</strong>：由于GC完成后空闲空间是一个连续的内存块，在内存分配时，只要申请空间小于空闲内存块，只需要移动free指针即可。相较于标记-清理算法使用空闲链表的分配方式，复制算法明显快得多，毕竟要在空闲链表中找到合适大小的内存怎么都得遍历这个链表。</li><li><strong>无碎片</strong>：没啥好说的。</li><li><strong>与缓存兼容</strong>：可以回顾一下前面说的局部性原理，由于所有存活对象都紧密的排布在内存里，非常有利于CPU的高速缓存。</li></ul><p>  相较于前面的两种GC算法，其劣势主要有亮点：</p><ul><li><strong>堆空间利用率低</strong>：复制算法把堆一分为二，只有一半能被使用，内存利用率极低，这也是复制算法的最大缺陷。</li><li><strong>递归调用函数</strong>：复制某个对象时要递归复制它引用的对象，相较于迭代算法，递归的效率更低，而且有栈空间溢出的风险。</li></ul><p>  也可以使用<strong>Cheney复制算法</strong>，利用广度优先算法，改变的 是从一开始就把根节点包含的对象先复制到TO中，使用两个指针scan和free进行操作，每有一个类复制，free就移动，每有一个类中的引用类被全部引用，scan就移动到下一个类上，直到scan与free相遇。对比之前的算法，Cheney算法的优点是使用<strong>迭代算法</strong>代替<strong>递归</strong>，避免了栈的消耗和可能的栈溢出风险，特别是拿堆空间用作队列来实现广度优先遍历，非常巧妙。而缺点则是，相互引用的对象并不是相邻的，就没办法充分利用缓存。这里不一一描述。</p></li></ul><p><strong>标记清除MarkSweep</strong></p><p>先把内存区域中的这些对象进行标记，然后把标记为垃圾的对象进行清理。但是如下图所示，存在<strong>执行效率不稳定和内存空间碎片化</strong>问题。空间碎片化会导致当需要分配较大的对象时无法找到连续的足够内存而不得不再来一次GC。</p><p><img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%206.png" alt="Untitled"></p><p><strong>标记整理算法Mark-Compact</strong></p><p>标记过程仍然与标记清除算法一样，但是后续步骤不是直接进行清理，而是让所有存活的对象都向一端移动，再清理掉边界以外的内存区域。主要用于老年代。</p><p><img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%207.png" alt="Untitled"></p><p>在新生代中，每次垃圾回收时都发现有<strong>大批对象死去</strong>，只有少量存活，就选用复制算法，只需要付出少量存活对象的<strong>复制成本</strong>就可以完成收集。老年代中因为<strong>对象存活率高、没有额外空间对它进行分配担保</strong>，就必须使用标记清理或者标记整理算法来进行回收</p><p><strong>新生代GC（Minor GC&#x2F;Young GC）</strong>：<br>发生在新生代的垃圾回收动作，新创建的对象优先在新生代Eden区进行分配，如果Eden没有足够的空间，就会触发MinorGC。因为大多数对象都是朝生暮死的，所以Minor GC非常频繁，回收速度也比较快。</p><p>在Minor GC期间，如果年轻代中的对象幸存下来（即没有被回收），它们会被<strong>晋升</strong>到老年代中。这会增加老年代的内存占用。<br><strong>老年代GC(Major GC&#x2F;OLD GC)</strong><br>发生在老年代的GC，发生Full GC时，一般会伴随着一次Minor GC，Full GC的速度比较一般会比Minor GC慢10倍以上。<br><strong>混合GC(Mixed GC)</strong></p><p>指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</p><p><strong>整堆收集(Full GC)</strong></p><p>收集整个Java堆和方法区的垃圾收集。</p><p><img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%208.png" alt="Untitled"></p><ul><li><p><strong>YoungGC 之前检查老年代</strong></p><p>  因为YoungGC结束后会把存活的对象上升至老年代，所以如果发现老年代可用的连续内存空间＜新生代历次YoungGC后升入老年代的对象总和的平均大小，就会触发YoungGC</p></li><li><p><strong>Young之后老年代空间不足</strong></p></li><li><p><strong>老年代空间不足</strong></p><p>  老年代内存使用率过高，达到一定比例就会触发。</p></li><li><p><strong>方法区内存空间不足</strong></p><p>  如果方法区由永久代实现，空间不足FullGC</p></li><li><p><strong>System.gc()</strong></p></li></ul><p><strong>对象进入老年代</strong></p><p><img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%209.png" alt="Untitled"></p><p><strong>长期存活的对象进入老年代</strong></p><p>在对象的对象头信息中存储着对象的迭代年龄，迭代年龄会在每次YoungGC之后对象的移区操作中增加，每一次移区年龄加一。当这个年龄达到15(默认)之后，这对象将会被移入老年代。<br><code>- XX:MaxTenuringThreshold</code></p><p><strong>大对象直接进入老年代</strong></p><p>一些占用大量连续内存的空间对象会在被加载时就直接进入老年代。这样的大对象一般是一些数组，长字符串之类的对。</p><p>HotSpot提供了参数：</p><p><code>-XX：PretenureSizeThreshold</code></p><p><strong>动态对象年龄判定</strong></p><p>为了能更好地适应不同程序的内存状况，HotSpot 虚拟机并不是永远要求对象的年龄必须达到<code>- XX：MaxTenuringThreshold</code> 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><p><strong>空间分配担保</strong></p><p>假如在 Young GC 之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接送入老年代。</p><h3 id="引用链GC-Roots"><a href="#引用链GC-Roots" class="headerlink" title="引用链GC Roots"></a>引用链GC Roots</h3><p>所谓GC Roots，就是一组必须活跃的引用，不是对象，是程序运行时的起点，是一切引用链的源头，Java中的GCRoots有：</p><ul><li><p><strong>虚拟机栈中的引用(方法的参数、局部变量等)</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">// 这里的 localVar 是一个局部变量，存在于虚拟机栈中System.out.println(localVar.toString());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StackReference</span>().greet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  在 greet 方法中，localVar 是一个局部变量，存在于虚拟机栈中，可以被认为是 GC Roots。</p><p>  在 greet 方法执行期间，localVar 引用的对象是活跃的，因为它是从 GC Roots 可达的。</p><p>  当 greet 方法执行完毕后，localVar 的作用域结束，localVar 引用的 Object 对象不再由任何 GC Roots 引用（假设没有其他引用指向这个对象），因此它将有资格作为垃圾被回收掉</p></li><li><p><strong>本地方法栈中JNI的引用</strong></p><p>  Java通过JNI(Java Native Interface)提供了一种机制，允许Java代码调用本地代码，通常是C或者C++）</p><p>  当调用Java方法，虚拟机创建一个栈帧并压入虚拟机栈。当它调用本地方法时，虚拟机会通过动态链接直接调用指定的本地方法。</p><p>  <img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%2010.png" alt="Untitled"></p><p>  JNI 引用是在 Java 本地接口（JNI）代码中创建的引用，这些引用可以指向 Java 堆中的对象。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设的JNI方法public native void nativeMethod();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设在C/C++中实现的本地方法/*</span></span><br><span class="line"> * Class:     NativeExample</span><br><span class="line"> * Method:    nativeMethod</span><br><span class="line"> * Signature: ()V</span><br><span class="line"> */JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title function_">Java_NativeExample_nativeMethod</span><span class="params">(JNIEnv *env, jobject thisObj)</span> &#123;</span><br><span class="line">    <span class="type">jobject</span> <span class="variable">localRef</span> <span class="operator">=</span> (*env)-&gt;NewObject(env, ...);<span class="comment">// 在本地方法栈中创建JNI引用// localRef 引用的Java对象在本地方法执行期间是活跃的&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  在本地（C&#x2F;C++）代码中，localRef 是对 Java 对象的一个 JNI 引用，它在本地方法执行期间保持 Java 对象活跃，可以被认为是 GC Roots。</p><p>  一旦 JNI 方法执行完毕，除非这个引用是全局的（Global Reference），否则它指向的对象将会被作为<strong>垃圾回收掉</strong>（假设没有其他地方再引用这个对象）</p></li><li><p><strong>类静态变量</strong></p><p>  类静态变量可以被认为是GC Roots，只要类未被卸载，静态变量引用的对象就不会被垃圾回收。如果类被卸载，那么静态变量引用的对象也有资格被垃圾回收。</p></li><li><p><strong>运行时常量池中的常量</strong></p><p>  在运行时常量池中的常量存储可以作为GC Roots.这些常量引用的对象在常量池中，只要包含这些常量的类未被卸载，这些对象就不会被垃圾回收。</p></li></ul><p><strong>finalize()方法</strong></p><p>在对对象进行可达性分析之后发现没有跟GCRoots相连接的引用链，那他就会被第一次标记，然后进行一次筛选，条件是此对象是否有必要执行finalize()方法。如果对象在finalize中重新与引用链上的任何一个对象建立关联就行，比如把this关键字赋值给某个类变量或者对象的成员变量，那么在第二次标记时就不会被回收。</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>JVM的垃圾收集器主要分为两大类：分代收集器和分区收集器。分代收集器的代表是CMS，分区收集器的代表是G1和ZGC。</p><p>就目前来说，JVM 的垃圾收集器主要分为两大类：分代收集器和分区收集器，分代收集器的代表是 CMS，分区收集器的代表是 G1 和 ZGC。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-28.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-28.png"></p><p><strong>Serial 收集器</strong></p><p>Serial 收集器是最基础、历史最悠久的收集器。</p><p>如同它的名字（串行），它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。</p><p>Serial&#x2F;Serial Old 收集器的运行过程如图：</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-29.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-29.png"></p><p><strong>ParNew</strong></p><p>ParNew 收集器实质上是 Serial 收集器的多线程并行版本，使用多条线程进行垃圾收集。</p><p>ParNew&#x2F;Serial Old 收集器运行示意图如下：</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-30.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-30.png"></p><p><strong>Parallel Scavenge</strong></p><p>Parallel Scavenge 收集器是一款新生代收集器，基于<strong>标记-复制</strong>算法实现，也能够并行收集。和 ParNew 有些类似，但 Parallel Scavenge 主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是 CPU 用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-31.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-31.png"></p><p>根据对象存活周期的不同会将内存划分为几块，一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p><p><strong>Serial Old</strong></p><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p><p><strong>Parallel Old</strong></p><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-32.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-32.png"></p><p><strong>CMS收集器</strong></p><p>以获取最短回收停顿时间为目标，采用<strong>标记-清除</strong>算法，JDK9被弃用，14被清除。</p><p>CMS 收集齐的垃圾收集分为四步：</p><ul><li><strong>初始标记</strong>（CMS initial mark）：单线程运行，需要 Stop The World，标记 GC Roots 能直达的对象。</li><li><strong>并发标记</strong>（（CMS concurrent mark）：无停顿，和用户线程同时运行，从 GC Roots 直达对象开始遍历整个对象图。</li><li><strong>重新标记</strong>（CMS remark）：多线程运行，需要 Stop The World，标记并发标记阶段产生对象。</li><li><strong>并发清除</strong>（CMS concurrent sweep）：无停顿，和用户线程同时运行，清理掉标记阶段标记的死亡的对象。</li></ul><p>Concurrent Mark Sweep 收集器运行示意图如下：</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-34.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-34.png"></p><p><strong>G1(Garbage-First Garbage Collector)</strong></p><p>在JDK1.7被引入，在JDK9取代CMS成为默认的垃圾收集器。G1有五个属性：分代、增量、并行、标记整理、STW。</p><p><img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%2011.png" alt="Untitled"></p><p>G1把连续的JAVA堆划分为多个大小相等的独立区域(Region)，每个Region都可以根据需要扮演Eden、Survivor或者老年代。收集器能对扮演不同角色的Region采用不同的策略去处理。</p><p>这样的好处是，避免了收集整个堆，而是按照若干个Region集进行收集，同时维护一个优先级列表，跟踪各个Region回收的价值，优先收集价值高的Region。</p><p>G1收集器的运行过程大致可以划分为下面四个步骤。</p><ul><li><strong>初始标记</strong>（initial mark），标记了从 GC Root 开始直接关联可达的对象。STW（Stop the World）执行。</li><li><strong>并发标记</strong>（concurrent marking），和用户线程并发执行，从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象、</li><li><strong>最终标记</strong>（Remark），STW，标记再并发标记过程中产生的垃圾。</li><li><strong>筛选回收</strong>（Live Data Counting And Evacuation），制定回收计划，选择多个 Region 构成回收集，把回收集中 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。需要 STW。</li></ul><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-36.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-36.png"></p><p><strong>有了 CMS，为什么还要引入 G1</strong></p><p>优点：CMS 最主要的优点在名字上已经体现出来——并发收集、低停顿。</p><p>缺点：CMS 同样有三个明显的缺点。</p><ul><li>Mark Sweep 算法会导致内存碎片比较多</li><li>CMS 的并发能力比较依赖于 CPU 资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。</li><li>并发清除阶段，用户线程依然在运行，会产生所谓的理“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。</li></ul><p>G1 主要解决了内存碎片过多的问题。</p><p><strong>ZGC收集器</strong></p><p>ZGC是JDK11时引入的一款低延迟的垃圾收集器，目标是不超过10ms的停顿时间内，为堆大小达到16TB的应用提供一种高吞吐量的垃圾收集器。</p><p>ZGC的两个关键的技术：<strong>指针染色</strong>和<strong>读屏障</strong>，不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器要进行一次内存访问，并将对象的存活信息放在对象头中；而在ZGC中，只需要设置指针地址的<strong>第42-45位</strong>即可，并且因为是寄存器访问，所以速度比访问内存更快。</p><p><strong>STW STOP the World</strong></p><p>进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，这样的停顿被成为STW。</p><p>在HotSpot中有个数据结构(映射表)被称为OopMap。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。在即时编译过程中，也会在<strong>特定的位置</strong>生产OopMap，记录下栈上和寄存器里哪些位置是引用。</p><p>这些特定的位置主要存在于</p><ul><li>循环的末尾(非counted循环)</li><li>方法临返回前&#x2F;调用方法的call指令后</li><li>可能会抛异常的位置</li></ul><p>这些位置就叫做安全点。用户程序执行时并非在代码指令流的任意位置都能够停顿下来进行垃圾收集，而是必须执行到安全点才能够暂停。</p><h3 id="垃圾收集器的选择"><a href="#垃圾收集器的选择" class="headerlink" title="垃圾收集器的选择"></a>垃圾收集器的选择</h3><table><thead><tr><th>Serial</th><th>如果应用程序有个很小的内存空间(约为100MB)亦或他子啊没有停顿时间要求的单线程处理器上运行。</th></tr></thead><tbody><tr><td>Parallel</td><td>如果优先考虑应用程序的峰值性能，并且没有时间要求，可以接受一秒或更长的停顿时间</td></tr><tr><td>CMS&#x2F;G1</td><td>如果响应时间比吞吐量优先级高，或者垃圾收集暂停必须保持大约在一秒内。</td></tr><tr><td>ZGC</td><td>如果响应时间是高优先级，或者堆空间比较大。</td></tr></tbody></table><p><strong>JDK8默认的垃圾回收器</strong></p><p>使用命令行：</p><p><code>java -XX:+PrintCommandLineFlags -version</code></p><p>可以看到<br><code>-XX:+UseParallelGC</code></p><p>UseParallelGC表示的是Parallel Scavege+ Parallel Old。表示的是新生代用的Scavege收集器，老年代用的 是Parallel Old收集器。</p><p>Parallel Scavege特点：高吞吐、</p><p><strong>JKD17默认的垃圾回收器</strong></p><p> <code>-XX:+UseG1GC</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM的对象</title>
      <link href="/2024/04/21/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/04/21/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM的对象"><a href="#JVM的对象" class="headerlink" title="JVM的对象"></a>JVM的对象</h1><p>在JVM中创建对象，从一个new指令开始：</p><p><img src="/images/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1%20a905ae6050c248cd95e32a9961204e7e/Untitled.png" alt="Untitled"></p><ul><li>首先检查这个指令的参数是否能在常量池中定位到一个类的符号</li><li>检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有就执行相应的类加载</li><li>类加载检查通过后，接下来虚拟机将为新生对象分配内存。</li><li>内存分配完之后，虚拟机将分配到的内存空间(不包括对象头)都初始化为零值。</li><li>接下来设置对象头，请求头里包含了对象是哪个类的实例，如何找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。</li></ul><p><strong>类加载的过程</strong></p><p><img src="/images/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1%20a905ae6050c248cd95e32a9961204e7e/Untitled%201.png" alt="Untitled"></p><ul><li><p><strong>加载：查找并加载类的二进制数据</strong></p><p>   是类加载过程中的一个阶段，而不是类加载</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流锁代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.Lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul></li><li><p><strong>验证：确保被加载的类的正确性</strong></p><p>  验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合JVM的规范的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全。</p><ul><li>文件格式验证</li><li>字节码验证</li><li>符号引用验证</li></ul></li><li><p><strong>准备：为类的静态变量分配内存，并将其初始化为默认值</strong></p><p>  准备阶段是正式为类中定义的变量。(即静态变量，被static修饰的变量)，分配内存并设置类变量初始值的阶段，也就是加载这种代码的时候</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span></span><br></pre></td></tr></table></figure><p>  他的初始化的value为0，而非123。</p></li><li><p><strong>解析：把类中的符号引用转换为直接引用初始化，为类的静态变量赋予正确的初始值</strong></p></li><li><p><strong>使用：主动使用和被动使用</strong></p></li><li><p><strong>卸载：满足条件后，被GC回收</strong></p></li></ul><h3 id="JVM中new对象的线程安全"><a href="#JVM中new对象的线程安全" class="headerlink" title="JVM中new对象的线程安全"></a><strong>JVM中new对象的线程安全</strong></h3><p>在JVM中，每次new一个对象都会分配内存。当线程A正在给A对象分配内存的时候，指针还没来得及修改，线程B就引用这个指针来分配内存，发生指针抢占和线程安全问题。</p><p>解决的方法：</p><ul><li>采用<a href="../%E7%BA%BF%E7%A8%8B%20bf18de630f1940a9a2d9326552b07a91/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%20dcb7684e9bdc4e4d8e6f91b17b06fcfa.md">CAS</a>分配重试的方式来保证更新操作的原子性</li><li>每个线程在Java堆中预先分配一小块内存，也就是<strong>本地线程分配缓冲(Thread Local Allocation Buffer)TLAB</strong>,要分配内存的线程，先在本地缓冲区分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</li></ul><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在Java中，对象的内存布局是由Java虚拟机规范定义的，单具体的实现细节可能因为不同的JVM而不同。例如HotSpot、OpenJ9等。</p><p>在HotSpot中，对象在堆内存中的存储布局可以划分为三个部分:</p><p><img src="/images/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1%20a905ae6050c248cd95e32a9961204e7e/Untitled%202.png" alt="Untitled"></p><ul><li><p>对象头是每个对象都有的,主要包括三部分信息:</p><ul><li><strong>标记字(MarkWord)</strong> 包含了对象自身运行时的数据，如哈希码、垃圾回收分代年龄、锁状态标志、线程持有的锁、偏向线程ID等信息。在64位操作系统下占八个字节，32位操作系统下占4个字节。</li><li>**类型指针(Class Pointer)**：指向对象所属类的元数据的指针，JVM通过这个指针来确定对象的类。在开启了压缩指针的情况下，这个指针可以被压缩，压缩到了一半占4个字节。</li><li>**数组长度(Array Length)**：如果对象是数组类型，还会有一个额外的数组长度字段，占四个字节。</li></ul><p>  可以通过 <code>java -XX:+PrintFlagsFinal -version | grep UseCompressedOops</code> 命令来查看当前 JVM 是否开启了压缩指针。在JDK8中是默认开启。  </p></li><li><p><strong>实例数据</strong></p><p>  存储了对象的具体信息，即在类中定义的各种字段数据(不包括父类继承的字段)。这部分大小取决于对象的属性和它们的类型。JVM会对这些数据进行对齐，以确保高效的访问速度。</p></li><li><p><strong>对齐填充</strong></p><p>  为了使对象的总大小是8字节的倍数(这是大多数现代计算机体系结构中最优访问边界)，JVM可能会在对象末尾添加一些填充。这部分是为了满足内存对齐的需求。</p></li></ul><h3 id="那么为什么要8字节对齐呢"><a href="#那么为什么要8字节对齐呢" class="headerlink" title="那么为什么要8字节对齐呢"></a><strong>那么为什么要8字节对齐呢</strong></h3><p>这是因为CPU进行内存访问的时候，一次寻址的指针大小是8字节，正好是L1缓存行的大小。如果不进行内存对齐，则可能出现跨缓存行访问，导致额外的缓存行加载，降低访问效率。</p><p><img src="https://cdn.tobebetterjavaer.com/stutymore/jvm-20240320222058.png" alt="https://cdn.tobebetterjavaer.com/stutymore/jvm-20240320222058.png"></p><p>比如说上图中 obj1 占 6 个字节，由于没有对齐，导致这一行缓存中多了 2 个字节 obj2 的数据，当 CPU 访问 obj2 的时候，就会导致缓存行的刷新，这就是缓存行污染。</p><p>也就说，8 字节对齐，是为了效率的提高，以空间换时间的一种方案。固然你还能够 16 字节对齐，可是 8 字节是最优选择。</p><p><strong>那么new一个Object()的大小是多少</strong></p><p>对象的大小是由对象头、实例数据和对其填充这三个部分组成的。</p><ul><li>对象头32位是8字节 64位上是12(默认压缩)</li><li>对于new的Object来说，实例数据可以视为0</li><li>对齐填充的大小取决于对象头和实例数据大小，确保对象的大小是8的倍数。</li></ul><p>所以在64位的JDK8的JVM上，一个new的Object是12字节头+4字节的对齐填充一共16字节。</p><p><strong>对象怎么访问定位</strong></p><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《JVM规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问堆中对象的具体位置。</p><p>主流的方式主要有使用<strong>句柄和直接指针</strong>两种。</p><ul><li><p><strong>使用句柄访问</strong></p><p>  Java堆中划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。</p></li></ul><p><img src="/images/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1%20a905ae6050c248cd95e32a9961204e7e/Untitled%203.png" alt="Untitled"></p><ul><li><p><strong>使用直接指针访问</strong></p><p>  Java堆中对象的内存布局必须考虑如何放置访问类型数据的相关信息。reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</p><p>  <img src="/images/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1%20a905ae6050c248cd95e32a9961204e7e/Untitled%204.png" alt="Untitled"></p><p>  <strong>句柄</strong>的好处是即使对象在垃圾收集的时候被移动的时候只需要改变句柄中的实例数据指针，reference不需要修改，比较稳定。</p><p>  <strong>直接指针</strong>的最大好处是速度快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是极为可观的执行成本。</p><p>  <strong>HotSpot虚拟主要使用直接指针。</strong></p></li></ul><p><strong>如何判断对象是否存活</strong></p><p><a href="JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81.md">引用计数和可达性</a></p><p><strong>对象的访问和对象的引用强度</strong></p><p>对象的访问涉及到java栈，java堆，方法区三个内存区域。</p><p>在JVM的访问方式使用的是指针访问方式。</p><p><img src="/images/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1%20a905ae6050c248cd95e32a9961204e7e/Untitled%205.png" alt="Untitled"></p><p><strong>对象的引用强度</strong></p><ul><li><p><strong>强引用</strong></p><p>  类似 Object object &#x3D; new Object()这种引用，只要强引用还存在，就永远不会被GC清除。</p></li><li><p><strong>软引用</strong></p><p>  用来描述一些还有用但是并非必须存在的对象，在JVM内存不足的时候会被GC回收。通过<strong>SoftReference</strong>来实现软引用，SoftReference很适合用于实现缓存。当GC扫描的软引用不经常使用时也会进行回收，可用softReference.get()获取。</p></li><li><p><strong>弱引用</strong></p><p>  弱引用也是用来描述一些还有用但是非必要的对象，强度会比软引用更加弱些。被弱引用关联的对象，生命周期只有一次GC。JDK通过WeakReference类来实现。当获取时，可以通过get方法获取，可能返回的是null。</p><p>  可传入一个ReferenceQueue对象到WeakReference构造，当引用对象被表示可回收时，isEnqueued会返回true。</p></li><li><p><strong>虚引用</strong></p><p>  又称为幻影引用，是最弱的一种引用关系。虚引用的作用是希望能在被GC回收的时候获得一个系统通知。可以通过PhantomReference类来实现。get方法永远返回null，当user从内存中删除时，调用isEnqueued会返回true。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>注释/API文档</title>
      <link href="/2024/04/21/%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3/"/>
      <url>/2024/04/21/%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="注释-API文档"><a href="#注释-API文档" class="headerlink" title="注释&#x2F;API文档"></a>注释&#x2F;API文档</h1><h3 id="除了单行注释和多行注释外，JAVA提供了一种文档注释。"><a href="#除了单行注释和多行注释外，JAVA提供了一种文档注释。" class="headerlink" title="除了单行注释和多行注释外，JAVA提供了一种文档注释。"></a>除了单行注释和多行注释外，JAVA提供了一种文档注释。</h3><p><strong>文档注释内容</strong>可以被JDK提供的工具<strong>javadoc</strong>所解析，生成一套以网页文件形式体现的该程序的说明文档。</p><p>文档注释的形式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>操作方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javadoc -d mydoc -author -version HelloWorld.java</span><br></pre></td></tr></table></figure><p>class需要为<strong>public</strong> ，执行之后会在本文件夹中生成一个新的文件夹mydir。在里面的<strong>index.html</strong>就是生成的程序说明文档。 </p><p>如果出现乱码，将编码模式改为GBK。</p><h2 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h2><p>**API(Application Programming Interface,应用程序接口)**是java提供的基本编程接口。</p><p>Java语言里面提供了大量的基础类，因此Oracle也为这些基础类提供相应 的说明文档，用于告诉开发如何使用这些类。</p><p>JAVA API文档，即为<strong>JDK的使用说明书</strong>。</p><p>在线API文档：</p><blockquote><p><a href="https://docs.oracle.com/en/java/javase/17/docs/api/index.html">https://docs.oracle.com/en/java/javase/17/docs/api/index.html</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM与注释&#92;API文档</title>
      <link href="/2024/04/21/JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3/"/>
      <url>/2024/04/21/JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM与注释-API文档"><a href="#JVM与注释-API文档" class="headerlink" title="JVM与注释\API文档"></a>JVM与注释\API文档</h1><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><strong>JVM的组织架构</strong></p><p><img src="/images/JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3%20d5060a3ae44143b2bcedbd4e92828014/Untitled.png" alt="Untitled"></p><p><strong>类加载器</strong></p><p>负责从文件系统、网络或者其他来源加载Class文件，将Class文件中的二进制数据读到内存中。</p><p><strong>运行时数据区</strong></p><p>JVM在执行Java程序时，需要在内存中分配空间来处理各种数据，在这些内存区域主要包括方法区、堆、栈、程序计数器和本地方法栈。</p><p><strong>执行引擎</strong></p><p>执行引擎是JVM的心脏，负责执行字节码。它包括一个虚拟处理器，还包括即时编译器JIT和垃圾回收期GC</p><h3 id="Java的优点"><a href="#Java的优点" class="headerlink" title="Java的优点"></a>Java的优点</h3><ol><li><p><strong>跨平台性:</strong> </p><p> java的核心优势，在最初设计的时候就很注重移植和跨平台性，比如：Java中的int永远是32位。</p><p> 因为虚拟机的存在，执行程序都是有虚拟机来保证程序在当前系统中的运行。</p></li><li><p><strong>面向对象性</strong></p><p> 面向对象是一种程序设计技术，非常适合大型软件的设计和开发。面向对象支持封装、继承、多态等特性，达到高聚合低耦合的标准。</p></li><li><p><strong>健壮性</strong></p><p>除了继承c&#x2F;c++的优点外，去掉了指针、内存的申请与释放等，提供了一个相对安全的内存管理和访问机制。</p></li><li><p><strong>安全性高</strong></p><p> Java适用于网络&#x2F;分布环境，需要提供一个安全机制以防恶意代码攻击，如安全防范机制（ClassLoader类加载器），可以分配不同的命名空间以防代替本地的同名类、字节代码检查。</p></li><li><p><strong>支持多线程</strong></p><p> C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能。而Java支持多线程操作。</p></li><li><p><strong>编译与解释并存</strong></p><p> 高级编程语言按照程序执行的方式分为<strong>编译型</strong>和<strong>解释型</strong>。编译型是至编译器针对特定的操作系统将源代码一次性翻译成可以被该平台执行的机器码。解释型是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</p><p> 编译型主要有<strong>C++、C、Swift、Rust</strong>等这些语言在编译时，会检查所有的语法和语义错误，因此，一旦编译成功，运行时通常具有较高的执行效率。但是，编译型语言的<strong>缺点</strong>在于，如果源代码发生变动，通常需要重新编译整个程序。</p><p> 解释型语言主要有<strong>JavaScript、Perl、Python、Ruby</strong>等。解释型语言的<strong>优点</strong>在于，开发过程灵活，代码修改后可以直接运行，无需重新编译整个程序。然而，由于解释型语言在运行时需要逐行解释源代码，因此执行效率通常较低。</p></li></ol><h3 id="JVM-JDK-与JRE"><a href="#JVM-JDK-与JRE" class="headerlink" title="JVM JDK 与JRE"></a>JVM JDK 与JRE</h3><p><strong>JVM</strong></p><p>Java的虚拟机，Java程序运行在JVM上，针对不同的系统都可以实现</p><p><strong>JRE</strong></p><p>Java的运行环境，是运行已编译Java程序所需的所有内容的合集，包括JVM、Java类库，Java命令和其他的一些基础构件，但是，不能用于创建新程序。</p><p><strong>JDK</strong></p><p>功能齐全的JavaSDK，拥有JRE拥有的一切，还有编译器Javac和工具javadoc、jdb等，讷讷感狗创建和编译程序。</p><p><strong>JDK&gt;JRE&gt;JVM</strong></p><p><img src="/images/JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3%20d5060a3ae44143b2bcedbd4e92828014/Untitled%201.png" alt="Untitled"></p><h3 id="JVM功能说明"><a href="#JVM功能说明" class="headerlink" title="JVM功能说明"></a>JVM功能说明</h3><p><strong>JVM具有强大的功能</strong>：</p><p><strong>功能1：实现Java程序的跨平台性</strong>。</p><p>Java程序在经过编译之类产生的.class文件，就是<strong>字节码</strong>。字节码能够被虚拟机识别，实现跨平台性。</p><p>Java程序从源代码到运行主要有<strong>三步</strong>：</p><ul><li>编译：将java代码编译成虚拟机可以理解 的字节码</li><li>解释：虚拟机将字节码翻译成机器码</li><li>执行：对应机器执行二进制机器码。</li></ul><p><img src="/images/JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3%20d5060a3ae44143b2bcedbd4e92828014/Untitled%202.png" alt="Untitled"></p><p><strong>功能2：自动内存管理（内存分配、内存回收</strong>）</p><pre><code>   涉及到运算的数据分配和存储都是有JVM来完成。JVM的存在消除人为回收无用内存空间的职责，提供一种系统级线程跟踪存储空间的分配情况，在空间达到相应的阈值的时候，检查释放可被释放的存储器空间，很大程度上减少了因为空间问题造成的内存泄漏</code></pre><p><strong>那Java还会出现内存溢出和内存泄漏吗？</strong></p><p>答案是会的。</p><p><strong>在JVM的底层，我们可以将其分为以下几个主要部分：</strong></p><ol><li><strong>硬件平台</strong>：JVM运行在特定的硬件平台上，如x86、ARM等。硬件平台提供了基础的计算、存储和I&#x2F;O能力，JVM需要利用这些能力来执行Java字节码。</li><li><strong>操作系统</strong>：操作系统是JVM的直接运行环境。操作系统提供了进程管理、内存管理、文件系统、网络通信等功能，JVM需要依赖这些功能来提供Java应用程序的运行环境。例如，JVM通过操作系统的内存管理功能来分配和回收内存，通过文件系统功能来加载和保存类文件等。</li><li><strong>JVM内核</strong>：JVM内核是JVM的核心部分，它负责执行Java字节码，提供Java应用程序的运行环境。JVM内核包括解释器、JIT编译器、垃圾回收器、类加载器等关键组件。<ul><li><strong>解释器</strong>：解释器负责逐条解释执行Java字节码。</li><li><strong>JIT编译器</strong>：JIT（Just-In-Time）编译器负责将Java字节码编译成本地机器码，以提高执行效率。</li><li><strong>垃圾回收器</strong>：垃圾回收器负责自动管理Java应用程序的内存，回收不再使用的对象占用的内存空间。</li><li><strong>类加载器</strong>：类加载器负责加载Java类文件到JVM中，为执行Java字节码提供基础。</li></ul></li><li><strong>Java类库</strong>：Java类库是JVM提供的一组标准库，它提供了许多常用的功能和接口，如文件操作、网络编程、数据库连接等。Java应用程序可以直接使用这些类和接口，而无需关心底层的实现细节。</li></ol><p><strong>内存调优</strong></p><p>原因：过多的GC和Full GC是会占用很多的系统资源，影响系统的吞吐量。</p><p>目的：减少Full GC次数，减少GC频率，尽量降低CG所导致的应用线程暂停时间。</p><p>手段：主要是针对内存管理方面发调优，包括各个代的大小，GC策略。</p><ul><li><p><strong>内存控制</strong></p><ul><li><p>OLD空间不足</p><p>  调优的时候尽量让对象在NEW被GC回收，让对象在新生代多存活一段时间和不要创建过大的对象记忆数组避免直接在旧生代创建对象</p></li><li><p>Pemanet Generation空间不足</p><p>  增大空间，避免太多静态对象</p></li><li><p>统计得到的GC后晋升到旧生代的平均大小大于旧生代剩余空间</p><p>  控制好新生代和旧生代比例</p></li><li><p>System.gc()被显示调用</p><p>  垃圾回收不要手动触发，尽量依靠JVM自身的机制</p></li></ul></li><li><p><strong>控制堆内存的各个部分的比例和GC策略失调</strong></p><ul><li><p>新生代设置过小</p><p>  一是GC次数频繁增大消耗，二是大对象被写入旧生代，诱发FullGC。</p></li><li><p>新生代设置过大</p><p>  一是新生代设置过大挤压旧生代的内存空间，诱发FullGC；二是新生代GC消耗大幅度增加。一般来说新生代占整个堆1&#x2F;3比较合适。</p></li><li><p>Survivor设置过小</p><p>  导致对象从eden直接到达旧生代，降低新生代存活时间。</p></li><li><p>Survivor设置过大</p><p>  导致eden过小，降低在新生代的存活时间</p></li><li><p>新生代存活时间太少</p><p>  通过-XX：MaxTenuringThreshold&#x3D;n来控制新生代的存活时间，尽量让对象在新生代被回收。</p></li></ul></li></ul><p><strong>GC策略</strong></p><ul><li><p><strong>吞吐量优先</strong></p><p>  JVM以吞吐量为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，来达到吞吐量指标。这个值可由-XX:GCTimeRatio&#x3D;n来设置</p></li><li><p><strong>暂停时间优先</strong></p><p>  JVM以暂停时间为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，尽量保证每次GC造成的应用停止时间都在指定的数值范围内完成。这个值可由-XX:MaxGCPauseRatio&#x3D;n来设置</p></li></ul><p><strong>JVM常见配置</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、堆设置</span><br><span class="line">-Xms:初始堆大小</span><br><span class="line">-Xmx:最大堆大小</span><br><span class="line">-XX:NewSize=n:设置年轻代大小</span><br><span class="line">-XX:NewRatio=n:设置年轻代和年老代的比值。如:为<span class="number">3</span>，表示年轻代与年老代比值为<span class="number">1</span>：<span class="number">3</span>，年轻代占整个年轻代年老代和的<span class="number">1</span>/<span class="number">4</span></span><br><span class="line">-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：<span class="number">3</span>，表示Eden：Survivor=<span class="number">3</span>：<span class="number">2</span>，一个Survivor区占整个年轻代的<span class="number">1</span>/<span class="number">5</span></span><br><span class="line">-XX:MaxPermSize=n:设置持久代大小</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、收集器设置</span><br><span class="line">-XX:+UseSerialGC:设置串行收集器</span><br><span class="line">-XX:+UseParallelGC:设置并行收集器</span><br><span class="line">-XX:+UseParalledlOldGC:设置并行年老代收集器</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、垃圾回收统计信息</span><br><span class="line">-XX:+PrintGC</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-Xloggc:filename</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、并行收集器设置</span><br><span class="line">-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</span><br><span class="line">-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、并发收集器设置</span><br><span class="line">-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</span><br><span class="line">-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</span><br><span class="line">注意:在对JVM内存调优的时候不能只看操作系统级别Java进程所占用的内存，这个数值不能准确的反应堆内存的真实占用情况，因为GC过后这个值是不会变化的，因此内存调优的时候要更多地使用JDK提供的内存查看工具，比如JConsole和Java VisualVM。</span><br></pre></td></tr></table></figure><p><strong>调优工具</strong>：</p><p><img src="/images/JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3%20d5060a3ae44143b2bcedbd4e92828014/Untitled%203.png" alt="Untitled"></p><p><strong>JDK可视化监控工具</strong></p><p>JConsole 在bin目录下，自动后自动搜索jvm进程，不需要指定。</p><p>是一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。用java写的GUI程序，用来监控VM，并可监控远程的VM，非常易用，而且功能非常强。</p><p>在cmd里面输入 jconsole，选则进程就可以了。<br>有概述，内存，线程，类，VM摘要和Mbean六个页签。<br>概述:显示有关JVM的监测值</p><p>内存: 显示内存使用信息</p><p>注意垃圾回收次数、时间、以及partial GC和full GC</p><p>线程: 显示线程使用信息</p><p>类: 显示类装载信息</p><p>VM摘要:显示java VM信息</p><p>MBeans: 显示 MBeans.</p><p><strong>ClassLoader的加载原理</strong></p><p>ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），当父亲已经加载了该类的时候，子ClassLoader不再加载，避免了重复加载。<br>双亲委派模型的工作工程：当一个类加载器收到一个类加载请求时，它首先不会先去加载这个类，而是把这个请求委托给<strong>父加载器</strong>，每一层的加载器都是如此，所以最终所有的加载请求都会传送到最上层的启动加载器。只有当父加载器反馈自己无法完成加载请求（它管理的范围之中没有这个类），子加载器才会尝试自己去加载。</p><p><a href="JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3%20d5060a3ae44143b2bcedbd4e92828014/%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3%2018776fe8949d431f9d80aed6ad9c9a93.md">注释&#x2F;API文档</a></p><p><a href="JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3%20d5060a3ae44143b2bcedbd4e92828014/JVM%E5%86%85%E5%AD%98%20325e7ed8480d4804bb7cdd691d1ef330.md">JVM内存</a></p><p><a href="JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3%20d5060a3ae44143b2bcedbd4e92828014/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81.md">JVM的垃圾收集</a></p><p><a href="JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3%20d5060a3ae44143b2bcedbd4e92828014/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1%20a905ae6050c248cd95e32a9961204e7e.md">JVM的对象</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>File类与IO流</title>
      <link href="/2024/04/17/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/"/>
      <url>/2024/04/17/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="File类与IO流"><a href="#File类与IO流" class="headerlink" title="File类与IO流"></a>File类与IO流</h1><p><strong>File类的理解</strong></p><p>File类位于java.io包下，File类的一个对象，对应与操作系统下的一个文件或一个文件目录（或文件夹）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String pathname)</span>;<span class="comment">//以pathname为路径创建File对象，可以是相对路径也可以是绝对路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String parent, String child)</span>;<span class="comment">//以parent为父路径，child为子路径创建File对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(File parent, String child)</span>;<span class="comment">//根据一个父File对象和子文件路径创造File对象</span></span><br></pre></td></tr></table></figure><p><strong>获取文件和目录的基本信息</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span><span class="comment">//获取名称</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span><span class="comment">//获取路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAbsolutePath</span><span class="params">()</span><span class="comment">//获取绝对路径</span></span><br><span class="line"><span class="keyword">public</span> File <span class="title function_">getAbsoluteFile</span><span class="params">()</span><span class="comment">//获取绝对路径表示的文件</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getParent</span><span class="params">()</span><span class="comment">//获取上层文件目录路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">length</span><span class="params">()</span><span class="comment">//获取文件的字节数，目录不行</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lastModified</span><span class="params">()</span><span class="comment">//获取最后一次修改时间</span></span><br><span class="line"><span class="keyword">public</span> String[] list()<span class="comment">//返回一个String数组，表示该Fiel目录中的所有子文件或目录</span></span><br><span class="line"><span class="keyword">public</span> File[] listFiles()<span class="comment">//返回一个File数组，表示该File目录中所有的子文件或者目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">renameTo</span><span class="params">(File dest)</span><span class="comment">//把文件重命名为指定的文件路径</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>Windows平台使用\ 在Java字符串中需要用\表示一个,Linux平台使用&#x2F;作为路径分隔符</p><p><strong>判断功能的方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span> <span class="comment">//此File表示的文件或目录是否实际存在</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span><span class="comment">//此File表示的是否为目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span><span class="comment">//此File表示的是否为文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canRead</span><span class="params">()</span><span class="comment">//判断是否可读</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWrite</span><span class="params">()</span><span class="comment">//判断是否可写入</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHidden</span><span class="params">()</span><span class="comment">//判断是否隐藏</span></span><br></pre></td></tr></table></figure><p><strong>创建与删除功能</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span><span class="comment">//创建文件</span></span><br><span class="line"><span class="keyword">public</span> File <span class="title function_">createTempFile</span><span class="params">()</span><span class="comment">//创建临时文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteOnExit</span><span class="params">()</span><span class="comment">//在JVM退出的时候自动删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdir</span><span class="params">()</span><span class="comment">//创建文件目录，如果存在或上层目录不存在，就不创建了</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span><span class="comment">//创建文件目录，如果上层文件目录不存在，一并创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span><span class="comment">//删除文件或者文件夹</span></span><br><span class="line">删除的注意事项：</span><br><span class="line"><span class="number">1.</span>Java中的删除不走回收站</span><br><span class="line"><span class="number">2.</span>删除一个文件目录，注意该文件目录内不能包含文件或者文件目录（干净的目录）</span><br></pre></td></tr></table></figure><p><strong>过滤函数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] listFiles = file.list(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File file, String name)</span>&#123;</span><br><span class="line"><span class="comment">//判断语句</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>File类中声明了以上各种功能，但是没有涉及到文件内容的读写操作，想要实现文件内容的读写，就需要使用IO流。File的对象，通常是作为IO流操作的文件的端点出现的。</p><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p><img src="/images/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%20ffd098987fc940b08165bbe1afeae826/Untitled.png" alt="Untitled"></p><p><strong>IO流</strong>分为输入流<strong>InputStream</strong>和输出流<strong>OutputStream</strong></p><p><strong>InputStream</strong></p><p>InputStream是Java标准库中提供的最基本的输入流，位于java.io这个包里面。InputStream不是一个接口，而是一个抽象类，是所有输入流的超类。</p><p>InputStream提供了read()的方法，用来读取文件的字节，并用返回字节表示的int值，如果读取完毕，就返回-1。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建一个FileInputStream对象:</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n); <span class="comment">// 打印byte的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    input.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputStream和OutputStream都是通过close()方法来关闭流，释放对应的底层资源。</p><p>使用try-catch来保证释放流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123; <span class="comment">// 利用while同时读取并判断</span></span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input != <span class="literal">null</span>) &#123; input.close(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>try ... finally</code>来编写上述代码会感觉比较复杂，更好的写法是利用Java 7引入的新的<code>try(resource)</code>的语法，只需要编写<code>try</code>语句，让编译器自动为我们关闭资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在读取字符的时候单个读取效率很低，可以使用缓冲区一次性读取多个字节，提高效率。InputStream提供了连个重载的方法来支持读取多个字节。</p><ul><li>int read(byte[] b)</li><li>int read(byte[] b, int off, intr len) 指定byte[]数组的起点和最大填充数。</li></ul><p>定义byte[]数组作为read()方法的入参，byte数组的长度限定了read方法读取字节的最大长度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((bytesRead = input.read(buffer, <span class="number">0</span>, buffer.length)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="comment">// 处理读取到的数据  </span></span><br><span class="line">                <span class="comment">// 例如，可以将其写入文件或输出到控制台  </span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>在测试的时候，不需要在本地真得建立一个txt，使用InputStream的子类的ByteArryInputStream来构造一个Stream来进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> readAsString(input);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readAsString</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sb.append((<span class="type">char</span>) n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>OutputStream</strong></p><p>OutputStream是Java提供的最基本的输出流，与InputStream类似，它是所有输出流的超类，重要的方法是write(int i)，虽然传参是int类型，但是只会写入一个字节，即只写入int表示的最低8为的字节的部分。</p><p>OutputStream还提供了flush()方法，将缓冲区的内容真正的输出到目的地。</p><p>每次写入一个字节的方法非常麻烦，OutputStream提供了重载方法write(byte [])来实现多数据输出。避免磁盘已满，无权限写入等问题，类似的，我们使用try(resource)来保证OutputStream是否发生IO错误的时候都能够正确地关闭。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line"><span class="keyword">try</span>(<span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;name:&quot;</span>))&#123;</span><br><span class="line">out.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时操作多个<code>AutoCloseable</code>资源时，在<code>try(resource) &#123; ... &#125;</code>语句中可以同时写出多个资源，用<code>;</code>隔开。例如，同时读写两个文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取input.txt，写入output.txt:</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">     <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    input.transferTo(output); <span class="comment">// transferTo的作用是?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transferTo等同于以下的循环操作，但是更为高效：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 假设使用1024字节的缓冲区  </span></span><br><span class="line"><span class="type">int</span> bytesRead;  </span><br><span class="line"><span class="keyword">while</span> ((bytesRead = input.read(buffer)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">    output.write(buffer, <span class="number">0</span>, bytesRead);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是</strong>，<code>transferTo</code> 方法可能无法传输所有的字节，即使源输入流中还有数据。这是因为 <code>transferTo</code> 方法可能在传输一定数量的字节后返回，或者在遇到 I&#x2F;O 错误时抛出异常。因此，如果你需要确保所有数据都被传输，你可能需要检查 <code>transferTo</code> 的返回值(-1)，并在必要时重复调用它，直到所有的数据都被传输。</p><p>同样的，我们也可以用用<code>FileOutputStream</code>可以从文件获取输出流，这是<code>OutputStream</code>常用的一个实现类。此外，<code>ByteArrayOutputStream</code>可以在内存中模拟一个<code>OutputStream</code>。</p><p>我们在开发过程中可能需要对流进行多种自定义操作，这样可以使用到<strong>Filter</strong>功能。</p><p>为了解决依赖继承导致子类数量失控的问题，JDK将InputStream分为提供数据基础和提供额外附加功能两大类</p><p><img src="/images/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%20ffd098987fc940b08165bbe1afeae826/Untitled%201.png" alt="Untitled"></p><p>这样，在我们使用不同功能的InputStream的时候，只需要在实例的时候包装就可以实现。无论我们包装多少次，得到的对象始终都是InputStream，直接引用就可以使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>();</span><br></pre></td></tr></table></figure><p>类似的，OutputStream也同样支持相同的操作。</p><p><img src="/images/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%20ffd098987fc940b08165bbe1afeae826/Untitled%202.png" alt="Untitled"></p><p>可以自定义Filter来实现需要的功能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readMyTest</span><span class="params">(InputStream input)</span>  <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">CountInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountInputStream</span>(input))&#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = inputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Total read &quot;</span> + inputStream.getBytesRead() + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CountInputStream(InputStream in) &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBytesRead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//计算stream中a的数量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.read();</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">97</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.read(b, off, len);</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.count += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不同服务端中的项目位置是不同的，导致无法固定配置文件的路径，使用classPath来读取文件，避免不同环境下文件路径不一致的问题。例如把default.properties文件放在classpath中，就无需关心实际存放的路径。</p><p><strong>通过序列化与反序列化可以进行数据的传输</strong></p><p>序列化的本质是把对象变成二进制数组，也就是byte[]。</p><p>把一个Java对象变为<code>byte[]</code>数组，需要使用<code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(buffer)) &#123;</span><br><span class="line">            <span class="comment">// 写入int:</span></span><br><span class="line">            output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">            output.writeUTF(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">            output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>ObjectOutputStream功能强大，既可以写入int，boolean等基本类型，也可以写入String(UTF-8)，还可以写入实现了Serializable接口的Object。</p><p>与ObjectOutputStream相反，ObjectOutputStream负责从一个字节流读取Java对象，也就是反序列化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(...)) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.readInt();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.readUTF();</span><br><span class="line">    <span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> (Double) input.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了能读取上诉类型之外，可以调用readObject()可以直接返回一个Object对象，再进行强转，该方法会抛出两个异常。</p><ul><li>ClassNotFoundException<ul><li>该情况常见与在不同终端上没有建立相同的对象，导致在接收终端无法找到对应的类。</li></ul></li><li>InvaildClassException<ul><li>这种情况常见于想序列化和反序列化中的字段类型冲突，导致class不兼容。</li></ul></li></ul><p>为了避免这种情况，Java序列化允许class定义一个特殊的serialVersionUID静态变量，用于标识Java类的序列化版本，由IDE自动生成。这样如果修改了字段，就会改变该值。</p><p><strong>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息</strong>。</p><h3 id="Reader-And-Writer"><a href="#Reader-And-Writer" class="headerlink" title="Reader And Writer"></a>Reader And Writer</h3><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取。</p><p>也就是说，在提供read()的方法中，返回的是0~65535的int类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;out/readme.txt&quot;</span>, StandardCharsets.UTF_8))&#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span>( (n = reader.read() )!= -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：FileReader带指定编码格式在Java8及以前的版本并不提供。</p><p>相对应Input流，<strong>Reader</strong>中也有对应的子类提供。</p><ul><li><p><code>CharArrayReader</code>可以在内存中模拟一个<code>Reader</code>，它的作用实际上是把一个<code>char[]</code>数组变成一个<code>Reader</code>，这和<code>ByteArrayInputStream</code>非常类似：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharArrayReader</span>(<span class="string">&quot;Hello&quot;</span>.toCharArray())) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>StringReader</code>可以直接把<code>String</code>作为数据源，它和<code>CharArrayReader</code>几乎一样。</p></li></ul><p>可以看出Reader与InputStream有着不小的关联，普通的<code>Reader</code>实际上是基于<code>InputStream</code>构造的，因为<code>Reader</code>需要从<code>InputStream</code>中读入字节流（<code>byte</code>），然后，根据编码设置，再转换为<code>char</code>就可以实现字符流。如果我们查看<code>FileReader</code>的源码，它在内部实际上持有一个<code>FileInputStream</code>。</p><p>这样，如果我们持有一个保存byte[]的InputStream，我们是否可以直接转为Reader类型。InputStreamReader就是Java提供的一个转换器，可以把任何InputStream转换为Reader</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也可以看作是一种FileReader的实现，在FileReader的源码中，可以看到其实是实现了FileInputStream。</p><p><strong>Writer与Reader类似，这里就不再进行赘述</strong>。</p><h3 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h3><p>从Java7开始，Java提供了这个工具类，极大的加快了工作速度。</p><p>Files提供的读写方法十分的方便：</p><ul><li><p>**<code>byte**[] data = Files.readAllBytes(Path.of(&quot;/path/to/file.txt&quot;));</code></p><p>  将文件的内容全部读取为byte[]</p></li><li><p><code>String content1 = Files.readString(Path.of(&quot;/path/to/file.txt&quot;));</code></p><p>  将文件内容全部读取为String，可以指定读取编码类型。</p></li><li><p>**<code>List**&lt;String&gt; lines = Files.readAllLines(Path.of(&quot;/path/to/file.txt&quot;));</code></p><p>  按行读取并返回每一行的内容</p></li><li><p><code>Files.write(Path.of(&quot;/path/to/file.txt&quot;), data);</code></p><p>  写入二进制文件</p></li><li><p><code>Files.writeString(Path.of(&quot;/path/to/file.txt&quot;), &quot;文本内容...&quot;, StandardCharsets.ISO_8859_1);</code></p><p>  根据编码类型写入文件</p></li><li><p><code>Files.write(Path.of(&quot;/path/to/file.txt&quot;), lines);</code></p><p>  按行写入文件</p></li></ul><p>此外，<code>Files</code>工具类还有<code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p><p><strong>注意</strong>：<code>Files</code>提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。</p><h3 id="BIO、NIO与AIO"><a href="#BIO、NIO与AIO" class="headerlink" title="BIO、NIO与AIO"></a><strong>BIO、NIO与AIO</strong></h3><p><img src="/images/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%20ffd098987fc940b08165bbe1afeae826/Untitled%203.png" alt="Untitled"></p><p><strong>Blocking I&#x2F;O</strong>：传统IO，同步阻塞，服务器实现模式为一个连接一个线程</p><p><img src="/images/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%20ffd098987fc940b08165bbe1afeae826/Untitled%204.png" alt="Untitled"></p><p>BIO方式适用于链接数目比较小而且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中。</p><p><strong>Java non-blocking IO</strong>，是指JDK提供的新的API。从1.4开始，提供了一系列改进的输入&#x2F;输出的新特性，被统称为NIO</p><p>NIO是<strong>同步非阻塞</strong>的，服务器端用一个线程处理多个连接，客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到链接有IO请求就进行处理。</p><p>NIO的数据在传输的时候是面向<strong>缓冲区Buffer</strong>的，必须从Buffer中读取或写入</p><p><img src="/images/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%20ffd098987fc940b08165bbe1afeae826/Untitled%205.png" alt="Untitled"></p><ul><li>每个Channel对应一个Buffer</li><li>Selector对应一个线程，一个线程对应多个Channel。</li><li>Selector会根据不同的事件，在各个通道上切换</li><li>Buffer是内存块，底层是数据</li></ul><p><strong>Asynchronous I&#x2F;O</strong>，AIO是异步不阻塞的I&#x2F;O。NIO就是reactor，当有事件触发时，服务器端得到通知，进行相应的处理，完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化就是把Java对象转换为二进制流，方便存储和传输。反序列化就是把二进制流恢复成对象。</p><p><strong>Serializable接口</strong></p><p>这个接口只是一个标记，没有具体的作用，但是如果不实现这个接口，在有些序列化的场景就会报错，所以建议创建JavaBean类都实现Serializable。</p><p><strong>serialVersionUID作用：</strong></p><p>起一个验证的作用，用来验证序列化对象和反序列化对象的ID是否一致。</p><p>对于不想序列化的变量，可以使用transient关键字修饰。</p><p><strong>transient</strong>：阻止实例中哪些用词关键字修饰的变量进行序列化。只能<strong>修饰变量</strong>。</p><p><strong>序列化的方式</strong></p><p><img src="/images/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%20ffd098987fc940b08165bbe1afeae826/Untitled%206.png" alt="Untitled"></p><ul><li>Java对象序列化：Java原生序列化方法即通过Java原生流I&#x2F;O Stream方法进行转化(上文)。</li><li>Json序列化：最常用的序列化方式，将对象转化为byte数组或者json串。</li><li>ProtoBuff 序列化：ProtocolBuffer 是一种轻便高效的结构化数据存储格式，ProtoBuff 序列化对象可以很大程度上将其压缩，可以大大减少数据传输大小，提高系统性能。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>API接口文档Swagger使用指南</title>
      <link href="/2024/04/17/API%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3Swagger%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2024/04/17/API%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3Swagger%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="API接口文档Swagger使用指南"><a href="#API接口文档Swagger使用指南" class="headerlink" title="API接口文档Swagger使用指南"></a>API接口文档Swagger使用指南</h1><p><em><strong>Swagger</strong></em>—一款致力于解决接口规范化、标准化、文档化的开源库，一款真正的开发神器。</p><p><em><strong>Swagger</strong></em>是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。Swagger是一个规范和完整的框架。用于生成、描述、调用和可视化RESTful风格的Web服务。</p><ul><li>对于后端来说<ul><li>不用手写WiKi接口手拼大量参数</li><li>对代码侵入性低，使用全注解的方式</li><li>方法参数名修改、增加、减少参数都可以直接生效，无需手动维护</li><li>缺点：增加开发成本，写接口还要再写一套参数配置。</li></ul></li><li>对于前端来说<ul><li>后端只需要定义接口就会自动生成文档，接口的参数和功能一目了然。</li><li>联调方便</li></ul></li></ul><h3 id="搭建一个Swagger"><a href="#搭建一个Swagger" class="headerlink" title="搭建一个Swagger"></a>搭建一个Swagger</h3><ul><li><p>引入Swagger的依赖</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- swagger --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-spring-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>SpringBoot整合swagger</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">productApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))  <span class="comment">//添加ApiOperiation注解的被扫描</span></span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>().title(”swagger和springBoot整合“).description(”swagger的API文档<span class="string">&quot;)</span></span><br><span class="line"><span class="string">                .version(&quot;</span><span class="number">1.0</span><span class="string">&quot;).build();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在controller上使用swagger的注解</p></li></ul><p>调用Swagger</p><p><a href="http://localhost:8093/swagger-ui.html">http://localhost:8093/swagger-ui.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇总</title>
      <link href="/2024/04/16/%E6%B1%87%E6%80%BB/"/>
      <url>/2024/04/16/%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p><a href="https://hyw20010212.github.io/2024/04/17/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/">单例设计与main()的理解</a></p><p><a href="https://www.notion.so/JVM-API-d5060a3ae44143b2bcedbd4e92828014?pvs=21">JVM与注释\API文档 </a></p><p><a href="https://www.notion.so/Static-final-eb56c1e3045c4e628e7c8fad6b66a884?pvs=21">Static与final</a></p><p><a href="https://www.notion.so/interface-bb982ec267f04ca0a775c2888ba193ab?pvs=21">接口interface</a></p><p><a href="https://www.notion.so/190eb41eb44c4aafb527d7fd518d7cda?pvs=21">内部类</a></p><p><a href="https://www.notion.so/285ecb55361642f2b7461eedf4b20b38?pvs=21">小知识</a></p><p><a href="https://www.notion.so/bf18de630f1940a9a2d9326552b07a91?pvs=21">线程</a></p><p><a href="https://www.notion.so/API-7d6ae30439d44567922fdb20f9b3c201?pvs=21">常用类与基础API</a></p><p><a href="https://www.notion.so/File-IO-ffd098987fc940b08165bbe1afeae826?pvs=21">File类与IO流</a></p><p><a href="https://www.notion.so/14beb6f4e4274158940f02bc7e43704a?pvs=21">反射</a></p><p><a href="https://www.notion.so/4b5ab83e3d894ed5867501f032b2e56d?pvs=21">异步编程</a></p><p><a href="https://www.notion.so/d57eabc5f3134c4a9d4648af6b0b93b0?pvs=21">泛型</a></p><p><a href="https://www.notion.so/Lambda-b9b7b56096e34313921ea8b78b0269b8?pvs=21">Lambda表达式</a></p><p><a href="https://www.notion.so/39cab743232b4e818b34b092de978b41?pvs=21">代码块</a></p><p><a href="https://www.notion.so/API-Swagger-55adf4934a924b4b86ffffea24c675eb?pvs=21">API接口文档Swagger使用指南</a></p><p><a href="https://www.notion.so/edff3e9eeff442fe87a30c74a245e229?pvs=21">异常处理</a></p><p><a href="https://www.notion.so/Mybatis-Plus-166eb8ddf4b64a7c8563c006b5a9a9bf?pvs=21">Mybatis Plus</a></p><p><a href="https://www.notion.so/abstract-7ec07dfc0e1345f0b28eab2e00632f8f?pvs=21">抽象类与抽象方法 abstract</a></p><p><a href="https://www.notion.so/Annotation-5ae77cca62f74e0d97f4508a76bf1127?pvs=21">注解Annotation</a></p><p><a href="https://www.notion.so/8e2dbf089c7b47e7bae37d30c94dbd20?pvs=21">单元测试</a></p><p><a href="https://www.notion.so/JMM-3bf254ca6b2d45d0bdcab80f6f5e0e55?pvs=21">JMM</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
