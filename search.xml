<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>异步编程</title>
      <link href="/2024/04/22/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/04/22/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p><strong>并发和并行</strong></p><p><strong>并发</strong>是指两个或多个事件在同一时间间隔内发生。系统支持两个或者多个动作线程同时存在，有多少线程队列就有多少并发量。并发的实现依赖于CPU切换线程。因为切换的时间特别短，所以基本对于用户是无感知的。<br><strong>并行</strong>是指系统具有同时进行运算或操作的特性。CPU有多少核心就有多少并行量，每个核心用于某一时刻的计算。</p><p><strong>异步编程</strong></p><p><strong>异步编程</strong>是一个并发编辑模型，允许程序在执行某些任<br>务时不必等待其完成，而是可以继续执行其他任务。这种编程模式通常用于处理耗时的操作，例如网络请求、文件I&#x2F;O、数据库查询等，以确保程序的响应性和性能。</p><p><strong>多线程编程</strong></p><p>多线程是指同时并发或者并行执行多个指令。</p><p>在<strong>单核处理器</strong>上，处理器通过调度算法在多线程之间进行切换和调度，或者根据外部输入(中断)和线程的优先级的组合来进行线程的切换。</p><p>在<strong>多核处理器</strong>上，线程才是真正的进行并行运行，多个处理器同时处理多个线程。</p><p><strong>@EnableAsync和@Async</strong></p><p>是Spring框架中用于支持异步方法执行的注解，两个注解经常一起使用，允许在Spring应用中轻松地执行异步操作。</p><p><strong>@EnableAsync</strong></p><p>是一个配置注解，用于启用Spring的异步方法执行功能，当在配置类中(@Configuration的类)上添加注解的时候，Spring会查找所有标有@Async的方法，并在单独的线程中异步执行。</p><p><strong>@Async</strong></p><p>是一个方法级别的注解，也可以用在类上，不可与**@Configuration**一起使用。用于标记一个方法应该异步执行。当你调用@Async的方法时，Spring会在单独的线程中执行它，不会阻塞当前线程。</p><p>被此注解标注的方法要么返回void要么返回<strong>Future</strong>。Async注解的唯一属性是value，是指定异步线程池的名称。</p><p><strong>@Async失效的场景</strong></p><ul><li>方法不是public或protected方法</li><li>方法使用static修饰</li><li>调用方与被调用方在同一个类中</li></ul><p><strong>Future和CompletableFuture</strong></p><p>Future是一个接口，系统允许你在主线程中启动一个子线程去执行一个耗时的任务，并立即返回一个Future对象，这个Future对象代表了这个任务的预期结果。</p><p>由于 <code>Future</code> 是一个接口，你不能直接实例化它。但是，你可以通过执行器（如 <code>ExecutorService</code>）的 <code>submit</code> 方法来获取一个实现了 <code>Future</code> 接口的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**Future&lt;String&gt; newsFuture = executor.submit(() -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> CommonUtils.readFile(<span class="string">&quot;news.txt&quot;</span>);</span><br><span class="line">&#125;);**</span><br></pre></td></tr></table></figure><p><strong>Future提供了几个方法：</strong></p><ul><li>cancel：用于取消任务的执行，如果任务成功被取消就返回true</li><li>get：用于获取任务执行的结果，如果任务尚未完成就会阻塞当前线程，直到任务完成。也可以设置时限。</li><li>isDone 任务是否完成</li><li>isCancelled 任务是否因为异常被取消</li><li>….</li></ul><p><strong>Future的不足</strong></p><ul><li>在没有使用get的情况下，无法对Future的结果进行进一步操作</li><li>无法结局任务互相依赖的问题</li><li>不能将多个Future合并在一起</li><li>没有专门的异常处理API</li></ul><p><strong>CompletableFuture</strong></p><p>实现了Future和CompletionStage接口，具有以下优势</p><ul><li>为快速创建、链接依赖和结合多个Future提供了大量的便利方法。</li><li>提供了适用于各种开发场景的回调函数。它还提供了非常全面的异常处理支持。</li><li>无缝衔接和亲和lambda表达式和Stream - API。</li></ul><h3 id="创建异步任务"><a href="#创建异步任务" class="headerlink" title="创建异步任务"></a>创建异步任务</h3><p><strong>runAsync</strong></p><p>如果你要异步运行某些耗时的后台任务，并且不想从任务中返回任何内容，则可以使用CompletableFuture.runAsync() 方法。它接受一个Runnable接口实现类对象，方法返回CompletableFuture<Void> 对象</Void></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br></pre></td></tr></table></figure><p><strong>supplyAsync</strong></p><p>需要从后台的异步任务中返回一个结果，使用supplyAsync。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br></pre></td></tr></table></figure><p>runAsync和supplyAsync都是开启单独的线程去执行一部任务，但是从未创建线程的话，CompletableFuture会从全局**ForkJoinPool.commonPool()**线程池获取来执行这些任务。</p><p>也可以创建一个线程池作为参数传递方法，使他们在指定的线程池中执行任务。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runAsync()重载</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable,Executor executor)</span></span><br><span class="line"><span class="comment">// spplyAsync()重载</span></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,Executor</span></span><br><span class="line"><span class="params">executor)</span></span><br></pre></td></tr></table></figure><p><strong>异步回调</strong></p><p>由于.get()方法是线程阻塞的，我们可以将回调附加到CompletableFuture上，当这个Future完成进行自动回调。</p><p><strong>thenApply</strong></p><p>thenApply()方法可以处理和转换CompletableFuture的结果。<strong>支持链式操作</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span></span><br></pre></td></tr></table></figure><p>Function&lt;T, U&gt;是一个函数式接口，表示一个转换操作，它接受类型T的参数并产生类型R的结果。</p><p><strong>thenAccept</strong></p><p>如果只想单纯的进行操作，不需要返回值，调用thenAccept()。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br></pre></td></tr></table></figure><p>通常作为回调链中的最后一个回调。</p><p><strong>thenRun</strong></p><p>如果只是从CompletableFuture的链式操作得到一个完成的通知，甚至都不使用上一个链式操作的结果,可以使用thenRun()。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(Runnable action)</span>;</span><br></pre></td></tr></table></figure><p>提供的以上三种方法都存在异步变体：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span></span><br><span class="line"><span class="comment">// 回调方的异步变体（异步回调）</span></span><br><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span></span><br><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn,</span></span><br><span class="line"><span class="params">Executor executor)</span></span><br></pre></td></tr></table></figure><p>进行一个实例测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThenApplyAsyncDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,</span><br><span class="line">            InterruptedException &#123;</span><br><span class="line"><span class="comment">//回顾： 异步读取filter_words.txt文件中的内容，读取完成后，转换成敏感词数组，主线程获取结果打印输出这个数组</span></span><br><span class="line">        CommonUtils.printTheadLog(<span class="string">&quot;main start&quot;</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">java</span>.util.concurrent.ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>));</span><br><span class="line">        CompletableFuture&lt;String[]&gt; filterWordFuture =</span><br><span class="line">                CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    CommonUtils.printTheadLog(Thread.currentThread().getName() + <span class="string">&quot;读取filter_words.txt文件&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">filterWordsContent</span> <span class="operator">=</span></span><br><span class="line">                            CommonUtils.readFile(<span class="string">&quot;D:\\DEMO\\qm-gzt-be\\qm-gzt-domain\\src\\main\\java\\com\\qm\\gzt\\psc\\domain\\demo\\test.txt&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> filterWordsContent;</span><br><span class="line">                &#125;).thenApplyAsync(content -&gt; &#123;</span><br><span class="line">                    CommonUtils.printTheadLog(Thread.currentThread().getName() + <span class="string">&quot;把文件内容转换成敏感词数组&quot;</span>);</span><br><span class="line">                    String[] filterWords = content.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> filterWords;</span><br><span class="line">                &#125;);</span><br><span class="line">        CommonUtils.printTheadLog(<span class="string">&quot;main continue&quot;</span>);</span><br><span class="line">        String[] filterWords = filterWordFuture.get();</span><br><span class="line">        CommonUtils.printTheadLog(<span class="string">&quot;filterWords = &quot;</span> +</span><br><span class="line">                Arrays.toString(filterWords));</span><br><span class="line">        CommonUtils.printTheadLog(<span class="string">&quot;main end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用默认线程池：<strong>ForkJoinPool</strong></p><p><img src="/.io//Untitled.png" alt="Untitled"></p><p>使用自定义的线程池：</p><p><img src="/.io//Untitled%201.png" alt="Untitled"></p><p>可以看到，虽然代码中设置了异步编程，但是在ForkJoinPool中还是使用了worker-1线程。</p><p>那么是怎么回事呢？</p><h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a><strong>ForkJoinPool</strong></h3><p>举个简单的例子，Fibonacci数列，F(N) &#x3D; F(N-1) + F(N-2)。当前数值的结果以来后面几个数值的结果，这时候用线程池貌似无法解决问题，虽然可以使用递归算法，但是速度较慢，无法发挥优势。</p><p><strong>ForkJoinPool就是设计来解决父子任务有依赖的并行计算问题的。</strong></p><p>常用的类似与快速排序，二分查找，集合运算等有父子以来的问题都可以解决。</p><p>ForkJoinPool的设计思想是<strong>分治算法</strong>，即将任务不断拆分成更小的任务，最终再join各个任务的计算结果，这样可以充分利用CPU资源，再结合工作窃取算法整体提高执行效率。</p><p><img src="/.io//Untitled%202.png" alt="Untitled"></p><p>在ForkJoinPool中有一个数组形式的成员变量workQqueue[]，对应一个队列数组，每个队列对应一个消费线程。丢入线程池的任务，根据特定规则进行转发。</p><p><img src="/.io//Untitled%203.png" alt="Untitled"></p><p>一般情况下，线程获取自己队列中的任务是LIFO(Last Input First Output后进先出)的方式，类似于栈的操作方式。如下图所示，首先放入队列的时候先将任务Push进队列的头部，之后消费的时候在pop出队列头部。</p><p><img src="/.io//Untitled%204.png" alt="Untitled"></p><p>当某个线程对应的队列空闲的时候，该线程则去队列的底部窃取任务到自己的队列进行消费。这样也笔迷拿了同时从顶部获取食物的线程冲突问题。</p><h3 id="异步任务编排"><a href="#异步任务编排" class="headerlink" title="异步任务编排"></a>异步任务编排</h3><p><strong>编排两个依赖关系的异步任务 thenCompose()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">thenCompose</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends</span></span><br><span class="line"><span class="params">CompletionStage&lt;U&gt;&gt; fn)</span></span><br></pre></td></tr></table></figure><p>thenApply(Fuction&lt;T,R&gt;)中Function回调会对上一步异步结果转换后得到一个简单值，但是在这种情况下，如果结果是嵌套的CompletableFuture，不符合预期。</p><p>也就是说，我们想结合上一步异步任务的结果给到下一个新的异步任务中，结果由这个新的异步任务返回。</p><p>使用thenCompose()方法代替，可以理解为<strong>异步任务的组合。</strong></p><p>当然，thenCompose()方法也存在异步回调的变体版本</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">thenCompose</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends</span></span><br><span class="line"><span class="params">CompletionStage&lt;U&gt;&gt; fn)</span></span><br><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends</span></span><br><span class="line"><span class="params">CompletionStage&lt;U&gt;&gt; fn)</span>CompletableFuture&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span></span></span><br><span class="line"><span class="params">T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span></span><br></pre></td></tr></table></figure><p><strong>编排两个非依赖关系的异步任务 thenCombine()</strong></p><p>上述方法用于一个Future依赖于另一个Future，使用thenCompose()用于组合两个Future。如果没有依赖关系，并且希望独立运行之后执行回调操作，可以使用thenCombine().</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;V&gt; <span class="title function_">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt;</span></span><br><span class="line"><span class="params">other,BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span></span><br></pre></td></tr></table></figure><p>同样存在异步回调</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;V&gt; <span class="title function_">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt;</span></span><br><span class="line"><span class="params">other,BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span></span><br><span class="line">CompletableFuture&lt;V&gt; <span class="title function_">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt;</span></span><br><span class="line"><span class="params">other,BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span></span><br><span class="line">CompletableFuture&lt;V&gt; <span class="title function_">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt;</span></span><br><span class="line"><span class="params">other,BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn, Executor executor)</span></span><br></pre></td></tr></table></figure><p><strong>合并多个异步 allOf&#x2F;anyOf</strong></p><p>上诉两个方法都是将两个CompletableFuture组合和合并在一起。如果想要编排任意数量的怎么办？</p><p>allOf和anyOf可以组合任意数量的Future</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title function_">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span><br></pre></td></tr></table></figure><p>有多个需要独立并运行的Future，并在这些Future都完成之后需要执行一些操作，就使用allOf。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// step 1: 创建List集合存储文件名</span></span><br><span class="line">List&lt;String&gt; fileList = Arrays.asList(<span class="string">&quot;news1.txt&quot;</span>, <span class="string">&quot;news2.txt&quot;</span>,</span><br><span class="line"><span class="string">&quot;news3.txt&quot;</span>);</span><br><span class="line"><span class="comment">// step 2: 根据文件名调用readFileFuture创建多个CompletableFuture,并存入</span></span><br><span class="line">List集合中</span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; readFileFutureList =</span><br><span class="line">fileList.stream().map(fileName -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> readFileFuture(fileName);</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// step 3: 把List集合转换成数组待用，以便传入allOf方法中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> readFileFutureList.size();</span><br><span class="line">CompletableFuture[] readFileFutureArr =</span><br><span class="line">readFileFutureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[len]);</span><br><span class="line"><span class="comment">// step 4: 使用allOf方法合并多个异步任务</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allOfFuture =</span><br><span class="line">CompletableFuture.allOf(readFileFutureArr);</span><br><span class="line"><span class="comment">// step 5: 当多个异步任务都完成后，使用回调操作文件结果，统计符合条件的文件个数</span></span><br><span class="line">CompletableFuture&lt;Long&gt; countFuture = allOfFuture.thenApply(v -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> readFileFutureList.stream()</span><br><span class="line">.map(future -&gt; future.join())</span><br><span class="line">.filter(content -&gt;</span><br><span class="line">content.contains(<span class="string">&quot;CompletableFuture&quot;</span>))</span><br><span class="line">.count();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当给定的多个异步任务中有任意Future一个需要完成时进行一些操作，可以使用anyOf方法。anyOf会返回一个新的completableFuture，新的姐夫哦和cfs已经完成的那个异步任务结果相同。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Object&gt; anyOfFuture =</span><br><span class="line">CompletableFuture.anyOf(future1, future2, future3);</span><br><span class="line"><span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> anyOfFuture.get();</span><br></pre></td></tr></table></figure><p>但是这也会产生一个问题，由于存在多个Future，将不知道最终Future的类型。</p><h3 id="异步任务的异常处理"><a href="#异步任务的异常处理" class="headerlink" title="异步任务的异常处理"></a>异步任务的异常处理</h3><p>如果任务中出现了异常，那么后续的回调都不会执行，CompletableFuture将传入异常处理。</p><p><strong>exceptionally()</strong></p><p>用于处理回调链上出现的任何异常，出现异常后不会继续回调，都会在exceptionally中执行异常处理。因为exceptionally只会处理一次异常，常常用在回调链的末端。</p><p><strong>handle()</strong></p><p>CompletableFuture还提供了一种更通用的方法handle()表示从异常中恢复。handle()常常用来恢复回调链中的一次特定异常，使回调链恢复后可进一步向下传递。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">handle</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span></span><br></pre></td></tr></table></figure><p><strong>异步回调的版本</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;T&gt; <span class="title function_">exceptionally</span><span class="params">(Function&lt;Throwable, ? extends T&gt; fn)</span></span><br><span class="line">CompletableFuture&lt;T&gt; <span class="title function_">exceptionallyAsync</span><span class="params">(Function&lt;Throwable, ? extends T&gt; fn)</span></span><br><span class="line"><span class="comment">// jdk17+</span></span><br><span class="line">CompletableFuture&lt;T&gt; <span class="title function_">exceptionallyAsync</span><span class="params">(Function&lt;Throwable, ? extends T&gt; fn,</span></span><br><span class="line"><span class="params">Executor executor)</span> <span class="comment">// jdk17+</span></span><br><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">handle</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span></span><br><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends</span></span><br><span class="line"><span class="params">U&gt; fn)</span></span><br><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends</span></span><br><span class="line"><span class="params">U&gt; fn, Executor executor)</span></span><br></pre></td></tr></table></figure><h3 id="异步任务的交互"><a href="#异步任务的交互" class="headerlink" title="异步任务的交互"></a>异步任务的交互</h3><p><strong>applyToEither</strong></p><p>把两个异步任务进行比较，哪个异步任务结果先到，就对先到的结果进行下一步操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other,</span></span><br><span class="line"><span class="params">Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span></span><br></pre></td></tr></table></figure><p>对应的回调版本</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other,</span></span><br><span class="line"><span class="params">Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span></span><br><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,</span></span><br><span class="line"><span class="params">Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span></span><br><span class="line">CompletableFuture&lt;U&gt; <span class="title function_">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,</span></span><br><span class="line"><span class="params">Function&lt;? <span class="built_in">super</span> T, U&gt; fn,Executor executor)</span></span><br></pre></td></tr></table></figure><p><strong>acceptEither</strong></p><p>把两个异步任务进行比较，异步任务先到的结果，对先到的结果进行消费操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; <span class="title function_">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other,</span></span><br><span class="line"><span class="params">Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br><span class="line">CompletableFuture&lt;Void&gt; <span class="title function_">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,</span></span><br><span class="line"><span class="params">Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br><span class="line">CompletableFuture&lt;Void&gt; <span class="title function_">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,</span></span><br><span class="line"><span class="params">Consumer&lt;? <span class="built_in">super</span> T&gt; action,Executor executor)</span></span><br></pre></td></tr></table></figure><p><strong>runAfterEither</strong></p><p>不关心结果，一个异步任务完成时就得到通知，使用runAfterEither().</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; <span class="title function_">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable</span></span><br><span class="line"><span class="params">action)</span></span><br><span class="line">CompletableFuture&lt;Void&gt; <span class="title function_">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable</span></span><br><span class="line"><span class="params">action)</span></span><br><span class="line">CompletableFuture&lt;Void&gt; <span class="title function_">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable</span></span><br><span class="line"><span class="params">action,Executor executor)</span></span><br></pre></td></tr></table></figure><h3 id="get-和join"><a href="#get-和join" class="headerlink" title="get()和join()"></a>get()和join()</h3><p>get和join都是CompletableFuture提供的以阻塞方式获取结果的方法。get()抛出检查时异常，需要程序必须处理；而join()方法抛出运行时异常，程序可以不处理。join()更适合在流式编程中。</p><h3 id="ParallStream-VS-CompletableFuture"><a href="#ParallStream-VS-CompletableFuture" class="headerlink" title="ParallStream VS CompletableFuture"></a><strong>ParallStream VS CompletableFuture</strong></h3><p><a href="%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API%207d6ae30439d44567922fdb20f9b3c201/Stream%E6%B5%81%E6%93%8D%E4%BD%9C%20d646cf566f1a44008156139c85ada857.md"><em><strong>stream</strong></em></a>本身提供了并行流ParallStream</p><p>Java中的并行流（parallelStream）和串行流（stream）主要有以下区别：</p><ol><li><strong>执行方式</strong>：并行流支持并行执行，能够提高程序运行效率。它利用多核处理器并行处理数据，适用于大量数据的处理。而串行流则按照顺序逐个处理数据，适用于线程安全、阻塞任务和重量级任务。</li><li><strong>线程安全</strong>：并行流可能存在线程安全问题，因为它是并行执行的。如果多个线程同时修改同一数据集，可能会引发线程安全问题。而串行流不存在这个问题，因为它是顺序执行的。</li><li><strong>数据处理</strong>：并行流适合处理没有线程安全问题、较单纯的数据处理任务。而串行流则适合处理存在线程安全问题、阻塞任务、重量级任务，以及需要使用同一事务的逻辑的任务。</li><li><strong>输出顺序</strong>：从执行结果来看，串行流的输出是有序的，而并行流的输出是无序的。</li><li><strong>执行耗时</strong>：并行流的执行耗时通常比串行流小很多。</li></ol><p>总的来说，并行流和串行流各有其适用场景，选择使用哪种取决于具体需求。如果需要提高处理大量数据的效率，且数据之间不存在线程安全问题，那么可以使用并行流。如果需要处理的数据量较小，或者数据之间存在线程安全问题，那么使用串行流更为合适。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> duration;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> duration)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.duration = duration;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟耗时的长任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">CommonUtils.printTheadLog(<span class="string">&quot;doWork&quot;</span>);</span><br><span class="line">CommonUtils.sleepSecond(duration);</span><br><span class="line"><span class="keyword">return</span> duration;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>耗时1.7s</p><p>使用CompletableFuture的优势是可以指定Excutor去处理事务，能选择更合适数量的线程。可以选择大于Runtime.getRuntime().availableProcessors()数量的线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// CompletableFuture 在流式操作中的优势</span></span><br><span class="line"><span class="comment">// 需求： 创建10个 MyTask 耗时的任务， 统计它们执行完的总耗时</span></span><br><span class="line"><span class="comment">// 方案三：使用CompletableFuture</span></span><br><span class="line"><span class="comment">// step 1: 创建10个MyTask对象，每个任务持续1s, 存入List集合</span></span><br><span class="line"><span class="type">IntStream</span> <span class="variable">intStream</span> <span class="operator">=</span> IntStream.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">List&lt;MyTask&gt; tasks = intStream.mapToObj(item -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">1</span>);</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 准备线程池</span></span><br><span class="line"><span class="type">int</span> N</span><br><span class="line"><span class="type">_</span></span><br><span class="line"><span class="variable">CPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// 设置线程池中的线程的数量至少为10</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">Executors.newFixedThreadPool(Math.min(tasks.size(),N_CPU * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// step 2: 根据MyTask对象构建10个异步任务</span></span><br><span class="line">List&lt;CompletableFuture&lt;Integer&gt;&gt; futures = tasks.stream().map(myTask</span><br><span class="line">-&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> CompletableFuture.supplyAsync(()-&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> myTask.doWork();</span><br><span class="line">&#125;,executor);</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// step 3: 执行异步任务，执行完成后，获取异步任务的结果，存入List集合中，统计总</span></span><br><span class="line">耗时</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">List&lt;Integer&gt; results = futures</span><br><span class="line">.stream()</span><br><span class="line">.map(CompletableFuture::join)</span><br><span class="line">.collect(Collectors.toList());</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">double</span> <span class="variable">costTime</span> <span class="operator">=</span> (end - start) / <span class="number">1000.0</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;processed %d tasks %.2f second&quot;</span>, tasks.size(),</span><br><span class="line">costTime);</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">executor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到使用CompletableFuture可以更好的控制线程池的数量，而parallelStream不能。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2024/04/21/ThreadLocal/"/>
      <url>/2024/04/21/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal叫做<strong>线程变量</strong>，意思是ThreadLocal中填充的变量属于当前线程，该变量对于其他线程来说是隔离的，也就是说该变量是当前线程独有的变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程去访问自己内部的副本，避免了并发场景下的线程安全问题。</p><p>ThreadLocal通常被<strong>private static</strong>修饰，当一个线程结束时，所使用的所有ThreadLocal相对的实力副本都会被回收。</p><p><img src="/images/ThreadLocal%204a508ec05f244d2487140cd0a25657e8/Untitled.png" alt="Untitled"></p><p>ThreadLocal是作为当前线程中属性ThreadLocalMap集合中的某一个Entry的key值Entry，在Map中以(ThreadLocal, value)的方式进行保存，虽然每个线程中的key是一样的，但是value不一样就形成了多个键值对，达到线程间变量隔离的目的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocaDemo</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line"><span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">System.out.println(str + <span class="string">&quot; :&quot;</span> + localVar.get());</span><br><span class="line"><span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">localVar.remove();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">ThreadLocaDemo.localVar.set(<span class="string">&quot;local_A&quot;</span>);</span><br><span class="line">print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="comment">//打印本地变量</span></span><br><span class="line">System.out.println(<span class="string">&quot;after remove : &quot;</span> + localVar.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">ThreadLocaDemo.localVar.set(<span class="string">&quot;local_B&quot;</span>);</span><br><span class="line">print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;after remove : &quot;</span> + localVar.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ThreadLocal与Synchronized的区别</strong></p><p>提到线程安全就会想到锁，那么两者的区别在哪里。</p><p>ThreadLocal其实是与线程绑定的一个变量。ThreadLocal和Synchronized都用于解决多线程并发。</p><ul><li>Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。</li><li>Synchronized是利用锁的机制，使变量或代码块在某一时刻只能被一个线程访问。而ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象。</li></ul><p><strong>关于内存问题</strong></p><p>ThreadLocal提供的remove方法可以移除当前线程绑定的局部变量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line"><span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;**</span><br></pre></td></tr></table></figure><p>remove方法直接将ThreadLocal对应的值从当前Thread中ThreadLocalMap中删除，解决内存泄漏问题。ThreadLocalMap中使用的key为ThreadLocal的<strong>弱引用</strong>，所以生命周期只有一个GC。但是value是强引用，就会造成一次GC之后出现key为null的脏键值对，所以在使用完ThreadLocal的时候一定要手动删除这个Entry。</p><h3 id="Thread、ThreadLocal和ThreadLocalMap"><a href="#Thread、ThreadLocal和ThreadLocalMap" class="headerlink" title="Thread、ThreadLocal和ThreadLocalMap"></a>Thread、ThreadLocal和ThreadLocalMap</h3><p>ThreadLocalMap是Thread的一个属性值，而ThreadLocal是维护ThreadLocalMap的。ThreadLocalMap底层是进行hash值保存的，所以会造成哈希冲突，ThreadLocalMap解决的办法就是进行<a href="../%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API%207d6ae30439d44567922fdb20f9b3c201/List%E3%80%81Set%E5%92%8CMap%207788ac0d9b13407b8d4a3b579aad607a.md">**开放地址法中的线性探测法</a>。**</p><p>对于不同的线程来说，每次获取副本值的时候，别的线程不能获取到当前线程的副本值，形成了隔离。</p><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>虽然名字中含有Map，但是并没有实现Map接口，结构与HashMap类似。主要还是：<strong>元素数组和散列方法</strong></p><p><img src="/images/ThreadLocal%204a508ec05f244d2487140cd0a25657e8/Untitled%201.png" alt="Untitled"></p><ul><li><p>元素数组：一个table数组存储Entry类型的元素，内容是key为ThreadLoccal的弱引用，Object为value的结构。</p></li><li><p>散列方法：散列方法就是对应怎么把对应的key映射到table数组的相应下标。使用的是哈希取余法。就是使用key的threadLocalHashCode和table数组的长度-1进行&amp;运算(相当于取余)。</p><p>  <strong>threadLocalHashCode</strong>：有意思的点就是每增加一个ThreadLocal对象，就会新增<strong>0x61c88647</strong>，这个值是个斐波那契数，也叫黄金分割数。hash增量设定为这个数，使哈希分布十分均匀。</p><p>  由于ThreadLocalMap没有使用链表解决冲突，所以哈希碰撞的时候使用的是开放地址法中的<strong>线性探测法</strong>。</p></li></ul><p><strong>扩容机制</strong></p><p>ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理发哦任何数据，且当前散列数组中Entry的数量已经达到列表扩容阈值(len*2&#x2F;3),就执行rehash().</p><p><strong>rehash</strong></p><p>先去清理过期的Entry，根据条件判断size≥threshold-threshold&#x2F;4来决定是否需要扩容。</p><h3 id="ThreadLocal常见的使用场景"><a href="#ThreadLocal常见的使用场景" class="headerlink" title="ThreadLocal常见的使用场景"></a><strong>ThreadLocal常见的使用场景</strong></h3><p><strong>存储用户Session</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadSession</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title function_">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException &#123;</span><br><span class="line"><span class="type">Session</span> <span class="variable">s</span> <span class="operator">=</span> (Session) threadSession.get();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">s = getSessionFactory().openSession();</span><br><span class="line">threadSession.set(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InfrastructureException</span>(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数据跨层传递</strong></p><p>每个线程内需要保存类似于全局变量的信息(例如在拦截器中获取的用户信息)，可以让不同的方法直接使用，避免参数传递的玛法却不想被多线程共享(因为不同线程获取的用户信息不一样)</p><p><strong>Spring使用ThreadLocal解决线程安全问题</strong></p><p>一般情况下，只有无状态的Bean才可以在多线程环境下共享，而在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全的状态性对象使用了ThreadLocal进行封装，赋予了状态。</p><p><strong>Slf4j日志输出中的应用</strong></p><p>JavaWeb中，经常使用Slf4j的Logback或Log4j来输出日志，Slf4j定义了MDC接口，要求实现多线程间日志隔离，Logback和Log4j正是利用ThreadLocal来实现的。</p><h3 id="跨线程传递"><a href="#跨线程传递" class="headerlink" title="跨线程传递"></a>跨线程传递</h3><p><strong>父子线程的数据共享</strong></p><p>ThreadLocal是线程的副本，不能用ThreadLocal进行父子传值。这时候可以使用InheritableThreadLocal。</p><p><strong>InheritableThreadLocal</strong></p><p>使用简单，在主线程的InheritableThreadLocal实例设置值，就可以在子线程中拿到了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>();</span><br><span class="line">        <span class="comment">// 主线程</span></span><br><span class="line">        threadLocal.set(<span class="string">&quot;不擅技术&quot;</span>);</span><br><span class="line">        <span class="comment">//子线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.run();</span><br><span class="line">                System.out.println(<span class="string">&quot;鄙人三某 ，&quot;</span> + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原理很简单：在Thread类中存在变量inheritableThreadLocals<strong>，</strong>inheritableThreadLocals不为空，就把它赋给当前的线程(子线程)的InheritableThreadLocals。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>阿里提供了TransmittableThreadLocal类，用于线程池之间跨线程的数据共享。</strong></p><p>引用依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;transmittable-thread-local&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">2.11</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>TransmittableThreadLocal继承于<strong>inheritableThreadLocal</strong>，内部维护了holder用来持有线程本地变量的数据存储。对ThreadLocal进行get(),set(),remove()等操作是在对holder进行操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt;</span><br><span class="line">holder = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; initialValue() &#123;</span><br><span class="line"><span class="comment">// 初始化一个空的WeakHashMap对象作为初始值</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;</span><br><span class="line">childValue(Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; parentValue) &#123;</span><br><span class="line"><span class="comment">// 将父线程的值作为参数传入，并创建了一个新的WeakHashMap对象来保存父线程的值，以实现</span></span><br><span class="line">线程值的继承和隔离</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;</span><br><span class="line">(parentValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>WeakHashMap与弱引用相似，特点是Map中的key不再被其他对象引用的时候，键值对就会自动移除。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>指令重排</title>
      <link href="/2024/04/21/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/"/>
      <url>/2024/04/21/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>java内存模型java Memory Model 简称<a href="../JMM%203bf254ca6b2d45d0bdcab80f6f5e0e55.md">JMM</a>，主要是用来屏蔽不同硬件和操作系统的内存访问差异的。不同硬件和不同操作系统下内存的访问不同，JMM解决了这个差异，同一相同代码在不同硬件和不同操作系统下的差异。</p><p>JMM规定，所有变量都必须存储在<strong>主内存</strong>中，每个线程也会有自己的工作内存，工作内存保存了该线程用到的变量和主内存的副本拷贝，对变量的操作都在工作内存中进行，不能直接读写主内存中的变量。</p><p><img src="/images/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%2018bc92bdc9e746ef8448c3c746876318/Untitled.png" alt="Untitled"></p><p>但是这样会带来内存可见性的问题，当某个线程修改了主内存共享变量的值之后，其他线程不能感知，还是会使用自身工作内存的旧值。</p><h3 id="指令重排-1"><a href="#指令重排-1" class="headerlink" title="指令重排"></a>指令重排</h3><p>在执行程序的时候，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为三种类型：</p><ul><li><p><strong>编译器优化的重排序</strong></p><p>  不改变单线程程序语义的前提下，重新安排语句的执行顺序。</p></li><li><p><strong>指令级并行的重排序</strong></p><p>  现代处理器采用了指令级并行技术来将多条指令重叠执行。</p></li><li><p><strong>内存系统的重排序</strong></p><p>  由于处理器使用缓存和读写缓冲区，使得加载和存储操作看上去可能是在乱序执行。</p></li></ul><p>Java的源代码到最终实际执行的指令序列，会分别经历以上三种重排序。</p><h3 id="指令重排的限制"><a href="#指令重排的限制" class="headerlink" title="指令重排的限制"></a>指令重排的限制</h3><p>指令重排存在一些限制，有happens-before和as-is-serial来约束。</p><p><strong>happens-before</strong></p><ul><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须按照happens-befor关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不违法。</li></ul><p><img src="/.io//Untitled%201.png" alt="Untitled"></p><ul><li><p><strong>程序顺序规则</strong></p><p>  一个线程中的每个操作，happens-before于该线程中的任意后续操作。</p></li><li><p><strong>监视器锁规则</strong></p><p>  对于一个锁的解锁，happens-before于随后对这个锁的加锁。</p></li><li><p><strong>volatile变量规则</strong></p><p>  对于以一个volatile域的写，happens-before于任意后续对这个volatile的读</p></li><li><p><strong>传递性</strong></p><p>  A happens-before B;B happens-before C; A happens-before C</p></li><li><p><strong>start()规则</strong></p><p>  如果线程A执行操作ThreadB.start(),那么A线程的ThreadB.start()操作happens-before线程b中的任意操作</p></li><li><p><strong>join()规则</strong></p><p>  如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</p></li></ul><p><strong>as-if-serial</strong></p><p>不管怎么重排序，单线程程序的执行结果<strong>不能被改变</strong>。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p>编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14</span>;   *<span class="comment">// A*</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1.0</span>;   *<span class="comment">// B*</span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r;   *<span class="comment">// C*</span></span><br></pre></td></tr></table></figure><p>上面 3 个操作的数据依赖关系：</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-24.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-24.png"></p><p>A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。</p><p>所以最终，程序可能会有两种执行顺序：</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-25.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-25.png"></p><p>as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器、runtime 和处理器共同编织了这么一个“楚门的世界”：单线程程序是按程序的“顺序”来执行的。as- if-serial 语义使单线程情况下，我们不需要担心重排序的问题，可见性的问题。</p><h3 id="volatile修饰"><a href="#volatile修饰" class="headerlink" title="volatile修饰"></a>volatile修饰</h3><p>只需要给共享变量加上volatile修饰即可</p><p>关键字volatile用来修饰成员变量，告知程序对该变量的访问都需要从<strong>共享内存</strong>中获取，而对它的改变必须同步刷新回共享内存，保证所有线程对变量的访问都具有可见性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;终止执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;设置 flag=true&quot;</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile有两个作用，保证<strong>可见性</strong>和<strong>有序性。</strong></p><p><strong>可见性</strong></p><p>相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，没有上下文切换的额外的开销成本。</p><p>volatile可以确保某个变量的更新对其他现场线程马上可见，一个变量被声明为volatile的时候，线程在写入这个变量的时候不会把值缓存在寄存器或者其他地方，而是会把值刷新进主内存。</p><p><strong>有序性</strong></p><p>通过限制<strong>编译器重排序</strong>和<strong>处理器重排序</strong>。</p><p>编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><ol><li>在每个 volatile 写操作的前面插入一个<code>StoreStore</code>屏障</li><li>在每个 volatile 写操作的后面插入一个<code>StoreLoad</code>屏障</li><li>在每个 volatile 读操作的后面插入一个<code>LoadLoad</code>屏障</li><li>在每个 volatile 读操作的后面插入一个<code>LoadStore</code>屏障</li></ol><p><strong>内存屏障</strong>是一种硬件机制，用于控制 CPU 缓存和主内存之间的数据同步。在 Java 中，内存屏障通常有两种：读屏障和写屏障。</p><p>在有内存屏障的地方，会禁止指令重排序，即屏障下面的代码不能跟屏障上面的代码交换执行顺序。在有内存屏障的地方，线程修改完共享变量以后会马上把该变量从本地内存写回到主内存，并且让其他线程本地内存中该变量副本失效（使用 MESI 协议）。</p><p>MESI 协议是一种缓存一致性协议，它是支持写回（write-back）缓存的最常用协议。MESI 协议基于总线嗅探机制实现了事务串形化，也用状态机机制降低了总线带宽压力，做到了 CPU 缓存一致性。MESI 协议这 4 个字母代表 4 个状态，分别是：Modified（已修改）、Exclusive（独占）、Shared（共享）、Invalidated（已失效）。</p><p><img src="/.io//Untitled%202.png" alt="Untitled"></p><p><img src="/.io//Untitled%203.png" alt="Untitled"></p><h3 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h3><p><strong>指令重排序</strong>是指编译器或 CPU 为了优化程序的执行性能，而对指令进行重新排序的一种手段。</p><p>指令重排序的实现初衷是好的，但是在多线程执行中，如果执行了指令重排序可能会导致程序执行出错。指令重排序最典型的一个问题就发生在单例模式中，比如以下问题代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// ①</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// ②</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上问题发生在代码 ② 这一行“instance &#x3D; new Singleton();”，这行代码<strong>看似只是一个创建对象的过程，然而它的实际执行却分为以下 3 步：</strong></p><ol><li><strong>创建内存空间。</strong></li><li><strong>在内存空间中初始化对象 Singleton。</strong></li><li><strong>将内存地址赋值给 instance 对象（执行了此步骤，instance 就不等于 null 了）。</strong></li></ol><p><strong>如果此变量不加 volatile，那么线程 1 在执行到上述代码的第 ② 处时就可能会执行指令重排序，将原本是 1、2、3 的执行顺序，重排为 1、3、2。但是特殊情况下，线程 1 在执行完第 3 步之后，如果来了线程 2 执行到上述代码的第 ① 处，判断 instance 对象已经不为 null，但此时线程 1 还未将对象实例化完，那么线程 2 将会得到一个被实例化“一半”的对象，从而导致程序执行出错，这就是为什么要给私有变量添加 volatile 的原因了。</strong> 要使以上单例模式变为线程安全的程序，需要给 instance 变量添加 volatile 修饰，它的最终实现代码如下：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟线程</title>
      <link href="/2024/04/21/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/04/21/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h1><h3 id="关于虚拟线程"><a href="#关于虚拟线程" class="headerlink" title="关于虚拟线程"></a>关于虚拟线程</h3><p>虚拟线程， 也叫做协程或者轻量线程，诞生于JDK19， 发布于JDK21，是一种在JVM中实现的逻辑线程，不直接和操作系统的物理线程一一对应，可以减少上下文切换带来的性能开销。</p><p><strong>操作系统线程、普通线程与虚拟线程的关系：</strong></p><p><img src="/.io//Untitled.png" alt="Untitled"></p><p>虚拟线程的使用：</p><ul><li><p><strong>Thread.startVirtualThread(Runnable task)</strong></p><p>  创建虚拟线程并直接启动执行任务</p></li><li><p><strong>Thread.ofVirtual.unstarted(Runnable task)</strong></p><p>  只创建虚拟线程，但不是直接启动</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建虚拟线程</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">vt</span> <span class="operator">=</span> Thread.ofVirtual().unstarted(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Do virtual thread.&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 运行虚拟线程</span></span><br><span class="line">vt.start();</span><br></pre></td></tr></table></figure></li><li><p><strong>Thread.ofVirtual().factory()</strong></p><p>  先创建虚拟线程工厂，然后再使用工厂创建虚拟线程，之后再调用start()方法进行执行</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建虚拟线程工厂</span></span><br><span class="line"><span class="type">ThreadFactory</span> <span class="variable">tf</span> <span class="operator">=</span> Thread.ofVirtual().factory();</span><br><span class="line"><span class="comment">// 创建虚拟线程</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">vt</span> <span class="operator">=</span> tf.newThread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Do virtual thread.&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 运行虚拟线程</span></span><br><span class="line">vt.start();</span><br></pre></td></tr></table></figure></li><li><p><strong>Executors.newVirtualThreadPerTaskExecutor()</strong></p><p>  ·使用线程池的方法直接创建虚拟线程：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个支持虚拟线程的线程池</span></span><br><span class="line">Executors.newVirtualThreadPerTaskExecutor();</span><br><span class="line">executor.submit(()-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Do virtual thread.&quot;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="虚拟线程对比普通线程"><a href="#虚拟线程对比普通线程" class="headerlink" title="虚拟线程对比普通线程"></a>虚拟线程对比普通线程</h3><ul><li>普通线程是和操作系统的物理线程是一一对应的，而虚拟线程是JVM层面的逻辑线程，并不和操作系统的物理线程一一对应，可以看作是轻量级的线程</li><li>普通线程默认创建的是用户线程，而虚拟线程是守护线程，其属性不能被修改，如果修改就会报错。</li><li>虚拟线程由JVM调度和使用，避免了普通线程频繁切换的性能开销，运行效率更高。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线程的创建方法</title>
      <link href="/2024/04/21/%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95/"/>
      <url>/2024/04/21/%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="线程创建方法"><a href="#线程创建方法" class="headerlink" title="线程创建方法"></a>线程创建方法</h1><h2 id="线程创建方法-1"><a href="#线程创建方法-1" class="headerlink" title="线程创建方法"></a>线程创建方法</h2><h3 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.继承Thread类"></a>1.继承Thread类</h3><p>创建一个继承与Thread的子类</p><p>重写Thread类中的run() —&gt;将此线程要执行的操作，声明在方法体中</p><p>创建当前子类的对象 通过对象调用start()</p><h3 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h3><p>有时候需要继承其他类就不能继承Thread类了 这时候实现Runnable接口来创建线程。</p><p>1.实现Runnable接口的类</p><p>2.实现接口中的run() </p><p>3.创建当前实现类的对象</p><p>4.将此对象作为参数传递到Thread类的构造器中，创建Thread实现类</p><p>5.start()启动线程 执行run()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Even</span> implenments Runnable&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvenTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"><span class="type">Even</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Even</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(e);</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="如果出现需要共享的数据"><a href="#如果出现需要共享的数据" class="headerlink" title="如果出现需要共享的数据"></a>如果出现需要共享的数据</h3><p>在方式2中数据建立在实现类中，在主函数中调用e一个对象， 所以不管几个线程都是共享的一个对象当中的数据。如果用方式1就需要增加static关键字。</p><h3 id="Thread类的常用结构"><a href="#Thread类的常用结构" class="headerlink" title="Thread类的常用结构"></a>Thread类的常用结构</h3><p><strong>线程的构造器</strong></p><p>-public Thread() 分配一个新的线程对象</p><p>-public Thread(String name) 分配一个指定名字的新的线程对象</p><p>-public Thread(Runnable target) 指定创建线程的目标对象 这个对象实现Runnable接口中的run方法</p><p>-public Thread(Runnable target, String name) 分配一个带有指定目标的带有名字的新线程对象。</p><p><strong>线程里的常用方法</strong></p><p><img src="/images/%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%20246e18b99ee946b0949ab7b45698d705/Untitled.png" alt="Untitled"></p><p>-<strong>start()</strong> 启动线程 调用线程的run</p><p>-<strong>run()</strong> 线程执行的操作</p><p>-<strong>currentThread()</strong> 获取当前线程</p><p>-<strong>getName() setName</strong></p><p>-<strong>sleep()</strong> 使当前线程睡眠 会抛出异常 静态方法。在主线程中调用<code>t.sleep</code>()，那么主线程会进入休眠状态。如果你在子线程中调用<code>t.sleep</code>()，那么子线程会进入休眠状态。</p><p>-<strong>yeild()</strong> 主动释放cpu执行权，但是线程调度器可能会装作看不见而忽略这个暗示。</p><p>-<strong>join()</strong> 在线程A中通过线程b调用 线程A进入阻塞 直到线程B结束再进行恢复 会抛出异常</p><p>-<strong>isAlive()</strong> 判断线程是否存活</p><p>-<strong>interrupt()</strong> 中止线程</p><p>-<strong>Thread.currentThread().isInterrupted()</strong> 方法检查当前线程是否被中断。</p><p>-<strong>Thread.interrupted()</strong> 方法检查当前线程是否被中断，并清除中断状态。</p><p><strong>锁行为</strong></p><p>当线程执行sleep方法时，不会释放任何锁，也就是说，如果一个线程在持有某个对象的锁时调用sleep，在睡眠期间仍会持有这个锁。</p><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>-getPriority() 获取线程的优先级</p><p>-setPriority() 设置线程的优先级【1-10】</p><h3 id="Thread类内部声明的三个常量"><a href="#Thread类内部声明的三个常量" class="headerlink" title="Thread类内部声明的三个常量"></a>Thread类内部声明的三个常量</h3><p>-MAX_PRIORITY(10) 最高优先级</p><p>-MIN_PRIORITY(1) 最低优先级</p><p>-NORM_PRIORITY(5) 普通优先级</p><p><strong>守护线程</strong></p><p>Java中的线程分为<strong>用户线程和守护线程</strong>，在JVM启动时会调用main方法，main方法所在的线程就是一个用户线程，在JVM内部同时启动了很多守护线程，比如垃圾回收线程。</p><p>守护线程与用户线程的区别是对JVM的作用。守护线程结束不影响JVM的正常退出，而只要有一个用户线程没有结束，JVM就不会正常退出。</p><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p><img src="/.io//Untitled%201.png" alt="Untitled"></p><h3 id="创建线程的方式三：实现Callable"><a href="#创建线程的方式三：实现Callable" class="headerlink" title="创建线程的方式三：实现Callable"></a>创建线程的方式三：实现Callable</h3><p><strong>对比Runnable的方式创建线程，存在的好处有:</strong></p><blockquote><p>call()可以有返回值，更灵活</p></blockquote><blockquote><p>call()可以使用throws的方式处理异常</p></blockquote><blockquote><p>call()Callable可以设置泛型</p></blockquote><p><strong>存在的缺点</strong></p><p>如果主线程中需要获取call的返回值，那么在call返回值之前，主线程处于阻塞的状态。</p><h3 id="创建线程的方式四：使用线程池"><a href="#创建线程的方式四：使用线程池" class="headerlink" title="创建线程的方式四：使用线程池"></a>创建线程的方式四：使用线程池</h3><p>Java标准库提供了ExecutorService接口来表示线程池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建固定大小的线程池:</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 提交任务:</span></span><br><span class="line">executor.submit(task1);</span><br><span class="line">executor.submit(task2);</span><br><span class="line">executor.submit(task3);</span><br><span class="line">executor.submit(task4);</span><br><span class="line">executor.submit(task5);</span><br></pre></td></tr></table></figure><p>Java标准库提供了几个常用实现类：</p><ul><li>FixedThreadPool：线程数量固定</li><li>CachedThreadPool：线程数根据任务动态调整的线程池。</li><li>SingleThreadExecutor：单线程执行</li><li>ScheduledThreadPool：定时及周期执行的线程池</li></ul><p>以上都被封装到Executors里，调用的时候类似：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executors.newFixedThreadPool(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p><strong>但是：阿里的Java开发手册禁止使用这种方式来创建线程。</strong></p><p><strong>优点</strong>：</p><blockquote><p>线程已经在线程池中提前建好，提高程序的执行效率</p></blockquote><blockquote><p>不再是用完即删，提高资源的复用率</p></blockquote><blockquote><p>可以设置相关的参数</p></blockquote><p>具体使用见—<a href="%E5%B8%B8%E8%A7%81%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%20e8570b67f440448fb3d0b55e52b2f0e0.md">常见线程池</a>—</p><p><strong>创建线程池的方法</strong></p><ul><li><p><strong>使用ThreadPoolExecutor类手动创建</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">2</span>, <span class="comment">// 核心线程数</span></span><br><span class="line">            <span class="number">5</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">            <span class="number">60</span>, <span class="comment">// 线程池中线程的空闲时间（单位为秒）</span></span><br><span class="line">            TimeUnit.SECONDS, <span class="comment">// 时间单位</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>) <span class="comment">// 任务队列</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行任务：&quot;</span> + taskId + <span class="string">&quot;，线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过 ThreadPoolExecutor 类手动创建了一个线程池</span></span><br><span class="line"><span class="comment">//设置了线程池的核心线程数为 2，最大线程数为 5，</span></span><br><span class="line"><span class="comment">//线程空闲时间为 60 秒，任务队列为长度为 10 的 ArrayBlockingQueue。</span></span><br><span class="line"><span class="comment">//然后我们通过 submit() 方法向线程池中提交了 20 个任务，</span></span><br><span class="line"><span class="comment">//每个任务会在执行时输出自己的编号和执行线程的名称，然后睡眠1秒钟模拟任务执行时间。</span></span><br><span class="line"><span class="comment">//最后，我们调用 shutdown() 方法关闭线程池。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>使用Executor类提供的工厂方法创建</strong></p><p>  使用 Executors 工厂类创建线程池虽然非常简单，但是在实际生产环境中并不推荐，因为这种方式很容易导致<strong>线程资源</strong>被耗尽，从而影响系统的性能和稳定性</p></li><li><p><strong>Spring提供的ThreadPoolTaskExecutor类</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTaskExecutorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">2</span>); <span class="comment">// 核心线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">5</span>); <span class="comment">// 最大线程数</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">10</span>); <span class="comment">// 任务队列长度</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行任务：&quot;</span> + taskId + <span class="string">&quot;，线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  我们使用了 Spring 框架中的 <strong>ThreadPoolTaskExecutor 类</strong>创建了一个线程池，设置了线程池的核心线程数为 2，最大线程数为 5，任务队列长度为 10。然后我们通过 submit() 方法向线程池中提交了 20 个任务，每个任务会在执行时输出自己的编号和执行线程的名称，然后睡眠1秒钟模拟任务执行时间。最后，我们调用 shutdown() 方法关闭线程池。注意，在使用 Spring 框架中的 ThreadPoolTaskExecutor 类创建线程池时，我们需要先调用 initialize() 方法进行初始化。</p></li></ul><p><strong>线程池的优点</strong></p><p><strong>复用线程，降低资源消耗</strong></p><p>线程创建的时候要求开辟虚拟机栈、本地方法栈、程序计数器等私有线程的内存空间，而销毁的时候又要回收这些空间。而使用 线程池的话就会复用线程、降低系统资源的消耗。</p><p><strong>提高相应速度</strong></p><p>线程是复用的而不是新建的，能够更快的响应任务和执行任务</p><p><strong>管控线程数和任务数</strong></p><p>线程池提供了更多的管理功能。</p><p><strong>线程池的参数</strong></p><ul><li><p><strong>corePoolSize 核心线程数</strong></p><p>  是指线程池中长期存活的线程数</p><p>  根据业务方法分为IO密集型和CPU密集型</p><p>  <strong>IO密集型任务</strong></p><p>  大部分的状况是CPU在等I&#x2F;O的读写操作，但是CPU的使用率不高。简单的说，就是需要大量的输入输出，例如读写文件、传输文件、网络请求。应该使用CompletableFuture。线程池的参考值可以设置为2*Ncpu。因为线程等待IO的时候不会占用CPU资源。</p><p>  <strong>CPU密集型</strong></p><p>  系统运行时候CPU的占用率达到100%，I&#x2F;O在很短的时间可以完成。这样的情况下使用比处理器更多的线程是没有什么意义的，所以选择ParallelStream，更容易使用，如果使用线程池，参数值可以设置为Ncpu+1；+1 是因为可能存在<strong>页缺失</strong>(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的<strong>进行线程上下文切换</strong>跟任务调度。</p></li><li><p><strong>maximiunPoolSize 最大线程数</strong></p><p>  允许创建的最大线程数，不能小于核心线程数</p></li><li><p><strong>keepAliveTime 空闲线程存活时间</strong></p><p>  空闲线程的存活时间 过了线程存活时间就会销毁一些线程，销毁的线程数&#x3D;最大线程数-核心线程数</p></li><li><p><strong>TimeUnit 时间单位</strong></p><p>  线程单位存活时间的描述单位</p></li><li><p><strong>BlockingQueue 线程池任务队列</strong></p><p>  线程池存放任务的对垒，用于存储线程池所有的待执行任务</p><ul><li><strong>ArrayBlockingQueue</strong>：一个由数组结构组成的有界阻塞队列。按FIFO排序</li><li><strong>LinkedBlockingQueue</strong>：一个由链表结构组成的有界阻塞队列。按FIFO排列，需要设置容量，不设置的话就是一个无边界的阻塞队列，最大长度是Integer.MAX_VALUE，吞吐量比上一个要高</li><li><strong>SynchronousQueue</strong>：一个不存储元素的阻塞队列，即直接提交给线程不保持它们。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<strong>LinkedBlockingQuene</strong>，newCacherThreadPool想线程池使用这个队列。</li><li><strong>PriorityBlockingQueue</strong>：一个支持优先级排序的无界阻塞队列。</li><li><strong>DelayQueue</strong>：延迟队列，一个使用优先级队列实现的无界阻塞队列，根据指定的执行时间从小到大排序否则按照插入到队列的先后排序。<strong>newScheduledThreadPool</strong>线程池使用这个队列。</li><li><strong>LinkedTransferQueue</strong>：一个由链表结构组成的无界阻塞队列。与SynchronousQueue类似，还含有非阻塞方法。</li><li><strong>LinkedBlockingDeque</strong>：一个由链表结构组成的双向阻塞队</li></ul></li><li><p><strong>ThreadFactory 创建线程的工厂</strong></p><p>  线程池创建线程时调用的工厂方法，可以通过这个方法设置线程的优先级，线程命名规则以及线程类型等</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建线程工厂</span></span><br><span class="line">    <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="comment">// 创建线程池中的线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">            <span class="comment">// 设置线程名称</span></span><br><span class="line">            thread.setName(<span class="string">&quot;Thread-&quot;</span> + r.hashCode());</span><br><span class="line">            <span class="comment">// 设置线程优先级（最大值：10）</span></span><br><span class="line">            thread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>,</span><br><span class="line">                                                                   TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),</span><br><span class="line">                                                                   threadFactory); <span class="comment">// 使用自定义的线程工厂</span></span><br><span class="line">    threadPoolExecutor.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;线程：%s，线程优先级：%d&quot;</span>,</span><br><span class="line">                                             thread.getName(), thread.getPriority()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>RejectedExecutionHandler 拒绝策略</strong></p><p>  当前线程池的任务超出线程池队列可以存储的最大值之后执行的策略.</p><ul><li>AbortPolicy 拒绝并抛出异常</li><li>CallerRunsPolicy 使用当前调用的线程来执行此任务</li><li>DiscardOldestPolicy: 抛弃队列头部最旧的一个任务,并执行当前任务</li><li>DiscardPolicy:忽略并抛弃当前任务</li></ul><p>  <strong>默认是AbortPolicy.</strong></p><p>  以下是对拒绝策略的具体说明</p><ul><li><p><strong>DiscardPolicy</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 任务的具体方法</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前任务被执行,执行时间:&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>() +</span><br><span class="line">                               <span class="string">&quot; 执行线程:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待 1s</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建线程,线程的任务队列的长度为 1</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                                           <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1</span>),</span><br><span class="line">                                                           <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy());</span><br><span class="line">    <span class="comment">// 添加并执行 4 个任务</span></span><br><span class="line">    threadPool.execute(runnable);</span><br><span class="line">    threadPool.execute(runnable);</span><br><span class="line">    threadPool.execute(runnable);</span><br><span class="line">    threadPool.execute(runnable);</span><br><span class="line">    <span class="comment">// 线程池执行完任务，关闭线程池</span></span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  以上代码可见，我们向线程池传递了四个任务，但是线程池的大小为1，等待队列为1.最多容纳两个线程，会得到以下的输出：</p><p>  <img src="/.io//Untitled%202.png" alt="Untitled"></p></li><li><p><strong>AbortPolicy</strong></p><p>  与上述代码相同的情况下，AbortPolicy会抛出异常；</p><p>  <img src="/.io//Untitled%203.png" alt="Untitled"></p></li><li><p><strong>自定义策略</strong></p><p>  当然除了 JDK 提供的四种拒绝策略之外，我们还可以实现通过 new RejectedExecutionHandler，并重写 rejectedExecution 方法来实现自定义拒绝策略，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 任务的具体方法</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前任务被执行,执行时间:&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>() +</span><br><span class="line">                               <span class="string">&quot; 执行线程:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待 1s</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建线程,线程的任务队列的长度为 1</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                                           <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1</span>),</span><br><span class="line">                                                           <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line">                                                               <span class="meta">@Override</span></span><br><span class="line">                                                               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">                                                                   <span class="comment">// 执行自定义拒绝策略的相关操作</span></span><br><span class="line">                                                                   System.out.println(<span class="string">&quot;我是自定义拒绝策略~&quot;</span>);</span><br><span class="line">                                                               &#125;</span><br><span class="line">                                                           &#125;);</span><br><span class="line">    <span class="comment">// 添加并执行 4 个任务</span></span><br><span class="line">    threadPool.execute(runnable);</span><br><span class="line">    threadPool.execute(runnable);</span><br><span class="line">    threadPool.execute(runnable);</span><br><span class="line">    threadPool.execute(runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>线程池提交execute和submit</strong></p><p>execute用于提交不需要返回值的任务，submit方法用于提交需要返回值的任务。线程池会返回一个<a href="../%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%204b5ab83e3d894ed5867501f032b2e56d.md">future</a>类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值。</p><p><strong>线程池的关闭</strong></p><ul><li><p><strong>调用方法停止线程</strong></p><ul><li>调用线程池的**shutdown()**方法来关闭线程池，该方法会停止线程池的接受新任务，并尝试将所有未完成的任务完成执行。</li><li>调用线程池的**shutdownNow()**方法来关闭线程池。该方法会停止线程池接受新任务，并尝试停止所有正在执行的任务，该方法会返回一个未完成的任务列表。</li></ul></li><li><p><strong>等待线程池停止</strong></p><p>  在关闭线程池后，通过调用**awaitTermination()**方法来等待所有任务完成执行。该方法会阻塞当前线程，直到所有任务完成执行或者等待超时。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 提交任务到线程池</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    executor.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">executor.shutdown();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 等待所有任务完成执行</span></span><br><span class="line">    <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">// 如果等待超时，强制关闭线程池</span></span><br><span class="line">        executor.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>判断线程池任务是否完成</strong></p><ul><li><p><strong>使用getCompletedTaskCount()统计已经执行完成的任务,和getTaskCount（）线程池的总任务进行对比，如果相等就表示任务已经完成。</strong></p><p>  缺点：因为线程池中的任务和线程的状态可能在计算过程中动态变化，因此返回的只是一个近似值。</p></li><li><p><strong>使用FutureTask等待所有任务执行完成</strong></p><p>  FutureTask的优势是任务判断精准，调用每个FutureTask的get方法就是等待该任务执行完成。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 FutrueTask 等待线程池执行完全部任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 创建任务</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task 1 start&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Task 1 end&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        FutureTask&lt;Integer&gt; task2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task 2 start&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Task 2 end&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task 3 start&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Task 3 end&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 提交三个任务给线程池</span></span><br><span class="line">        executor.submit(task1);</span><br><span class="line">        executor.submit(task2);</span><br><span class="line">        executor.submit(task3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有任务执行完毕并获取结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> task1.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> task2.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result3</span> <span class="operator">=</span> task3.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Do main thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>使用CountDownLatch或CyclicBarrier等待所有线程的执行完之后，再执行后续流程。</strong></p><p>  CountDownLatch和CyclicBarrier类似，都是等待所有任务达到某个点之后，再进行后续的操作。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">20</span>,</span><br><span class="line">    <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">1024</span>));</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskCount</span> <span class="operator">=</span> <span class="number">5</span>;    <span class="comment">// 任务总数</span></span><br><span class="line">    <span class="comment">// 单次计数器</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(taskCount); <span class="comment">// ①</span></span><br><span class="line">    <span class="comment">// 添加任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; taskCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 随机休眠 0-4s</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">sleepTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(sleepTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;任务%d执行完成&quot;</span>, finalI));</span><br><span class="line">                <span class="comment">// 线程执行完，计数器 -1</span></span><br><span class="line">                countDownLatch.countDown();  <span class="comment">// ②</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞等待线程池任务执行完</span></span><br><span class="line">    countDownLatch.await();  <span class="comment">// ③</span></span><br><span class="line">    <span class="comment">// 线程池执行完</span></span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(<span class="string">&quot;线程池任务执行完成！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>CountDownLatch的核心方法</strong></p><ul><li>**await()**：等待latch降为0；</li><li>**boolean await(long timeout, TimeUnit unit)**设置超过时间。</li><li><strong>coutDown()</strong>:latch数量减一</li><li><strong>getCount()</strong>:获取当前的latch数量。</li></ul><p>  <strong>缺点</strong>：CountDownLatch缺点是计数器只能使用一次，CountDownLatch创建之后不能被重复使用。</p><p>  **CyclicBarrier(同步屏障)<strong>和CountDownLatch相似，可以理解为一个可以</strong>重复使用的循环(Cyclic)计数器屏障(Barrier)**，CyclicBarrier可以调用reset方法将自己重置到初始的状态。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">20</span>,</span><br><span class="line">    <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">1024</span>));</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskCount</span> <span class="operator">=</span> <span class="number">5</span>;    <span class="comment">// 任务总数</span></span><br><span class="line">    <span class="comment">// 循环计数器 ①</span></span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(taskCount, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 线程池执行完</span></span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程池所有任务已执行完！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 添加任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; taskCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 随机休眠 0-4s</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">sleepTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(sleepTime);</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;任务%d执行完成&quot;</span>, finalI));</span><br><span class="line">                    <span class="comment">// 线程执行完</span></span><br><span class="line">                    cyclicBarrier.await(); <span class="comment">// ②</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  <img src="/.io//Untitled%204.png" alt="Untitled"></p><p>  <strong>CyclicBarrier三个重要方法：</strong></p><ul><li><p><strong>构造方法：</strong></p><p>  传递两个参数，第一个参数是计数器的数量，第二个参数是runnable。计数器参数为零时，执行第二个参数中的runnable；</p></li><li><p><strong>await():</strong></p><p>  再CyclicBarrier上进行阻塞等待，当调用此方法时CyclicBarrier的内部计数器会-1，直到：</p><ul><li>CyclicBarrier上等待的线程数量达到计数器的数量时，则所有线程被释放，继续执行</li><li>当线程被中断，则派出IInterruptedException异常，停止等待，继续执行。</li><li>其他等待的线程被中断，抛出BrokenBarrierException异常，停止等待，继续执行</li><li>其他等待线程超时，当前线程抛出BrokenBarrierException异常，停止等待，继续执行</li><li>其他线程调用reset方法的时候，当前线程BrokenBarrierException异常，停止等待，继续执行</li></ul></li><li><p><strong>reset()方法</strong></p><p>  使CyclicBarrier回归初始状态，做到了：</p><ul><li>如果有正在等待的线程，BrokenBarrierException异常，停止等待，继续执行</li><li>将是否破损标志位broken设置为false</li></ul></li></ul><p>  <strong>两者的区别</strong></p><table><thead><tr><th>CyclicBarrier</th><th>CountDownLatch</th></tr></thead><tbody><tr><td>CyclicBarrier 是可重用的，其中的线程会等待所有的线程完成任务。届时，屏障将被拆除，并可以选择性地做一些特定的动作。</td><td>CountDownLatch 是一次性的，不同的线程在同一个计数器上工作，直到计数器为 0.</td></tr><tr><td>CyclicBarrier 面向的是线程数</td><td>CountDownLatch 面向的是任务数</td></tr><tr><td>在使用 CyclicBarrier 时，你必须在构造中指定参与协作的线程数，这些线程必须调用 await()方法</td><td>使用 CountDownLatch 时，则必须要指定任务数，至于这些任务由哪些线程完成无关紧要</td></tr><tr><td>CyclicBarrier 可以在所有的线程释放后重新使用</td><td>CountDownLatch 在计数器为 0 时不能再使用</td></tr><tr><td>在 CyclicBarrier 中，如果某个线程遇到了中断、超时等问题时，则处于 await 的线程都会出现问题</td><td>在 CountDownLatch 中，如果某个线程出现问题，其他线程不受影响</td></tr></tbody></table></li></ul><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore(信号量)是用来控制同时访问特定资源的线程数量，通过协调各个线程来保证合理的使用资源。本质是协调多个线程对共享资源的获取。</p><p><img src="/.io//Untitled%205.png" alt="Untitled"></p><p>比如要控制只有十个线程并发工作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println(<span class="string">&quot;save data&quot;</span>);</span><br><span class="line">                        s.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然设定了30个线程，但是只有10个并发执行。Semaphore的构造方法接受整型的数字，表示可用的许可证数量。acquire()是获得一个许可证，release是归还许可证。还可以用tryAcquire来获取许可证。</p><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>Exchanger是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换，提供了一个同步点，在这个同步点，两个线程可以交换彼此的数据。</p><p>两个线程通过exchange方法来交换数据，如果第一个线程先执行exchanger()方法，它会一直等待第二个线程也执行这个方法，两个线程都达到同步点时，进行数据交换。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> <span class="string">&quot;银行流水A&quot;</span>; <span class="comment">// A录入银行流水数据</span></span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> <span class="string">&quot;银行流水B&quot;</span>; <span class="comment">// B录入银行流水数据</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> exgr.exchange(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;A和B数据是否一致：&quot;</span> + A.equals(B) + <span class="string">&quot;，A录入的是：&quot;</span></span><br><span class="line">                            + A + <span class="string">&quot;，B录入是：&quot;</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果害怕出现一直等待，可以设置最大等待时间。</p><p><strong>总结</strong>：</p><p>在实现判断线程池任务是否执行完成的方案中，通过统计线程池执行完任务的方式（实现方法 1），以及实现方法 3（CountDownLatch 或 CyclicBarrier）等统计，都是“不记名”的，只关注数量，不关注（具体）对象，所以这些方式都有可能受到外界代码的影响，因此使用 <strong>FutureTask</strong> 等待具体任务执行完的方式是最推荐的判断方法。</p><h3 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h3><p><img src="/.io//Untitled%206.png" alt="Untitled"></p><p>1.线程池刚刚创建，里面不存在线程。</p><p>2.调用execute()方法添加 一个任务时，线程池进行判断：</p><ul><li>如果正在运行的线程数量小于核心数量，马上创建线程进行运行。</li><li>如果线程数大于等于核心数，那么将任务放入队列中</li><li>如果队列满了，而且正在运行的数量小于最大核心数，创建非核心线程处理任务。</li><li>如果队列满了，线程数又等于最大核心数，执行拒绝策略。</li></ul><p>3.当一个线程完成任务时，从队列取下一个任务来执行</p><p>4.当一个线程无事可做，超过一定时间时，线程池中非核心线程数就会被停掉。</p><h3 id="线程池的异常处理"><a href="#线程池的异常处理" class="headerlink" title="线程池的异常处理"></a>线程池的异常处理</h3><p>使用线程池处理任务的时候，任务代码可能抛出<strong>RuntimeException</strong>，抛出异常后，线程池可能捕获他，也可能创建一个新的线程来代替他。</p><p><strong>常见的异常处理方式</strong></p><p><img src="/.io//Untitled%207.png" alt="Untitled"></p><h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a><strong>线程池的状态</strong></h3><p><img src="/.io//Untitled%208.png" alt="Untitled"></p><ul><li><strong>Running</strong><ul><li>该状态的线程池会接受新任务，并处理阻塞队列中的任务。</li><li>调用线程池的shutdown()方法，可以切换到SHUTDOWN状态。</li><li>调用线程池的shutdownNow()方法，可以切换到STOP状态。</li></ul></li><li><strong>SHUTDOWN</strong><ul><li>该状态的线程池不会接受新任务，但是会处理阻塞队列中的任务</li><li>队列为空，并且线程池中执行的任务也为空，进入TIDYING状态。</li></ul></li><li><strong>STOP</strong><ul><li>该状态的线程不会接受新任务，也不处理，而且会中断正在运行的任务</li><li>线程池中执行的任务为空，进入TIDYING状态</li></ul></li><li><strong>TIDYING</strong><ul><li>状态表明所有的任务已经运行种植，记录的任务数量为0。</li><li>terminated执行完毕，进入TERMINATED状态</li></ul></li><li><strong>TERMINATED</strong><ul><li>代表线程池彻底终止</li></ul></li></ul><h3 id="设计一个简单的线程池"><a href="#设计一个简单的线程池" class="headerlink" title="设计一个简单的线程池"></a>设计一个简单的线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qm.gzt.psc.domain.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> huyaowen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> MyThreadPool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024-03-28 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPool</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maxPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maxPoolSize, BlockingQueue&lt;Runnable&gt; queue)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maxPoolSize = maxPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable command)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ctrl.get()&gt;=maxPoolSize)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(command);</span><br><span class="line">        worker.thread.start();</span><br><span class="line">        ctrl.incrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        Runnable task;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable task)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">            <span class="built_in">this</span>.thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> task;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(runnable!=<span class="literal">null</span>||(runnable = getTask())!=<span class="literal">null</span>)&#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">                <span class="keyword">if</span>(ctrl.get()&gt;maxPoolSize)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                runnable = <span class="literal">null</span>;</span><br><span class="line">            &#125;&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                ctrl.decrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;queueSize:&quot;</span>+ queue.size());</span><br><span class="line">                <span class="keyword">return</span> queue.take();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctrl.get();</span><br><span class="line">        <span class="comment">// 添加到核心中</span></span><br><span class="line">        <span class="keyword">if</span>(c&lt;corePoolSize)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!addWorker(command))&#123;</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加到队列中</span></span><br><span class="line">        <span class="keyword">if</span>(!queue.offer(command))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!addWorker(command))&#123;</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单机线程执行断电了怎么办：对阻塞队列持久化；正在处理任务事务控制；断电之后正在处理任务的回滚，通过日志恢复该次操作；服务器重启后阻塞队列中的数据再加载。</p><h3 id="线程释放"><a href="#线程释放" class="headerlink" title="线程释放"></a>线程释放</h3><p>核心线程默认情况下是不会被回收的，只有额外线程在空闲时间达到阈值的时候才会被回收。那么怎回收，怎么保证核心线程不被回收。</p><p>try {<br>           &#x2F;&#x2F; 5. 这里是关键：timed&#x3D;&#x3D;true 意思是线程数大于核心线程数的时候，从队列里面取值并加了个 keepAliveTime 超时时间，如果超过这个时间还没取到任务，就timedOut&#x3D;true, 然后再次循环的时候，上面第4步的if 条件就满足了，就会return null, 然后就会释放线程了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//超时标志</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">//1. 线程池状态为 SHUTDOWN并且队列为空或者STOP的时候会返回 null, 释放当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">                &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;</span><br><span class="line">           ...</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 2. 获取当前线程池中线程的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 当允许核心线程超时或者 当前线程数量大于核心线程数时 timed = true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">    <span class="comment">// 4. timed == true 并且 timeOut == true 并且 队列任务为空且线程池线程存在的情况下，返回null, 释放当前线程</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">           <span class="comment">// Worker 线程数减一操作</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 5. 这里是关键：timed==true 意思是线程数大于核心线程数的时候，从队列里面取值并加了个 keepAliveTime 超时时间，如果超过这个时间还没取到任务，就timedOut=true, 然后再次循环的时候，上面第4步的if 条件就满足了，就会return null, 然后就会释放线程了。</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是实现的代码，timed&#x3D;true的意思是线程池大于核心线程数的时候，从队列中取值并且加上了keepAliveTIme超时时间，如果超过了这个时间还没有取到任务，timeout &#x3D; true，然后再次循环就会return null，释放线程。</p><p>对于核心线程来说，<strong>allowCoreThreadTimeOut</strong>这个参数来控制是否能释放核心线程数。这个参数默认是false，如果设置为true，上述第三步就不会判断当前线程数是否大于核心数这个条件，也就是说，线程池中只要有线程就可以释放。</p><p>通过AtomicInteger修饰ctl变量，高3位存储线程池状态，低29位存储线程的个数，通过一个变量完成两件事情，完成状态判断以及限制线程的最大数量。使用一个HashSet存储Worker的引用，而Worker继承了AbstractQueuedSynchronizer，实现一个一个不可重入的独占锁保证线程的安全。</p><p><img src="/.io//Untitled%209.png" alt="Untitled"></p><p>美团提供了一个可修改的队列ResizableCapacityLinkedBlockingQueue。在LinkedBlockingQueue的源码中，capacity的修饰是ginal的，这个地方采用voaltile修饰，对外暴露可修改，就可以实现动态修改阻塞队列大小。</p><h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p>线程池中的运行对于我们来说就像一个黑盒，没有办法了解线程池中的运行状态，出现问题没有办法及时判断和预警。</p><p>对于监控，核心逻辑就是拿到关键指标，然后进行上报，就可以实现监控和预警。</p><p><strong>ThreadPoolExecutor中提供了以下方法来获取线程池中的指标。</strong></p><ul><li>getCorePoolSize()获取核心线程数</li><li>getMaximumPoolSize()获取最大线程数</li><li>getQueue():获取线程池中的阻塞队列</li><li>getPoolSize()：获取线程池中的工作线程数。</li><li>getActiveCount():获取活跃线程数。</li><li>getLargestPoolSize()：获取线程池曾经到过的最大工作线程数。</li><li>getTaskCount():获取历史已完成以及正在执行的总的任务数量。</li></ul><p>ThreadPoolExecutor中还提供了一些<strong>未实现的钩子方法</strong>，可以通过重写这些方法来实现更多指标数据的获取。</p><ul><li>beforeExecute：在Worker线程执行任务之前会调用的方法。</li><li>afterExecute：在Work线程执行之后会调用的方法。</li><li>terminated：当线程池从状态变更到TERMINATED状态之前调用的方法。</li></ul><p>例如可以在beforeExecute方法中记录任务开始时间，在afterExecute方法来计算任务的耗时。</p><h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork&#x2F;Join框架"></a>Fork&#x2F;Join框架</h3><p>Fork&#x2F;Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干小任务，最终汇总到每个小任务结果后得到大任务的结果的框架。</p><p>详情见：<a href="../%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%204b5ab83e3d894ed5867501f032b2e56d.md">Fork</a>；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线程安全</title>
      <link href="/2024/04/21/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/2024/04/21/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h3 id="线程安全问题与线程的同步机制"><a href="#线程安全问题与线程的同步机制" class="headerlink" title="线程安全问题与线程的同步机制"></a>线程安全问题与线程的同步机制</h3><p><strong>在一个线程操作共享数据的时候另一个线程可能也进行操作 使用线程的同步机制避免出现问题。</strong></p><p>同步限制器， 俗称为锁，哪个线程获取了锁，哪个线程就能执行需要同步的代码。</p><p><strong>同步代码块</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;&#125;</span><br></pre></td></tr></table></figure><p>同步监视器可以使用<strong>任何一个类的对象</strong>充当。但是多个线程必须共用<strong>同一个</strong>同步监视器(可用static)。或者当前类的class（类.class）</p><p><img src="/.io//Untitled.png" alt="Untitled"></p><p><strong>同步方法</strong></p><p>操作共享数据的代码完整的声明在了一个方法中，那么我们就可以将此方法声明为同步方法。</p><p>添加<strong>synchronized</strong>修饰 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> synchroned <span class="keyword">void</span></span><br></pre></td></tr></table></figure><p>同步监视器默认为this。</p><p><strong>synchronized</strong>用来保证代码的原子性。</p><p>主要有三种用法：</p><ul><li><p><strong>修饰实例方法</strong></p><p>  作用于当前对象实例加锁，进如同步代码前要获得<strong>当前对象实例的锁</strong>。</p></li><li><p><strong>修饰静态方法</strong></p><p>  给当前类加锁，会作用于类的所有对象实例，进入同步代码前要获得当前类的锁，因为静态成员不属于任何一个实例对象，是类成员。</p><p>  <strong>注意</strong>：如果一个线程A调用一个实例对象的非静态方法，线程B调用静态方法，都有锁，不会发生互斥现象。因为静态方法的锁是当前类的锁，非静态方法是当前实例对象的锁。</p></li><li><p><strong>修饰代码块</strong></p><p>  指定加锁对象，对给定对象&#x2F;类加锁。synchronized(this\object)表示进入同步代码块前要获得给定对象的锁。</p><p>  <strong>sunchronized的实现原理</strong></p><p>  synchronized修饰的时候，不需要你自己去lock和unlock，是因为JVM已经帮我们把这个事情做了。</p><p>  JVM采用了monitorenter、monitorexit两个指令来实现同步，monitorenter指令指向同步代码块的开始位置，monitorexit指向结束位置。</p><ul><li><p><strong>修饰代码块</strong></p><p>  反编译一段synchronized修饰代码块的代码，<code>javap -c -s -v -l SynchronizedDemo.class</code>，可以看到相应的字节码指令。</p></li></ul><p>  <img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-30.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-30.png">  </p></li><li><p><strong>修饰方法</strong></p><p>  JVM采用ACC_SYNCHRONIZED标记符来实现同步，这个标识指明了该方法是一个同步方法。</p><p>  <img src="/.io//Untitled%201.png" alt="Untitled"></p></li></ul><p>以上三个方法都是基于<strong>Monitor实现</strong>的。</p><p>实例对象结构里面有对象头，对象头中有一块结构交MarkWord，MarkWord指针指向monitor。</p><p>Monitor是一种同步工具，也可以说是一种同步机制。是由<strong>ObjectMonitor</strong>实现的，可以叫<strong>内部锁</strong>，或者<strong>Monitor锁</strong>。</p><p><strong>ObjectMonitor 的工作原理：</strong></p><ul><li>ObjectMonitor 有两个队列<strong>：_WaitSet、_EntryList</strong>，用来保存 ObjectWaiter 对象列表。</li><li>_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>; *<span class="comment">// 记录线程获取锁的次数*</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;  *<span class="comment">//锁的重入次数*</span></span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;  *<span class="comment">// 指向持有ObjectMonitor对象的线程*</span></span><br><span class="line">    _WaitSet      = NULL;  *<span class="comment">// 处于wait状态的线程，会被加入到_WaitSet*</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ;  *<span class="comment">// 处于等待锁block状态的线程，会被加入到该列表*</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/.io//Untitled%202.png" alt="Untitled"></p><ul><li>monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1。</li><li>monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。</li></ul><h3 id="synchronized保证可见性、有序性、可重入性"><a href="#synchronized保证可见性、有序性、可重入性" class="headerlink" title="synchronized保证可见性、有序性、可重入性"></a>synchronized保证可见性、有序性、可重入性</h3><ul><li><p><strong>可见性</strong></p><p>  线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。线程加锁后，其他线程无法获取主内存中的共享变量</p><p>  线程解锁前，必须把共享变量的最新值刷新到主内存中去。</p></li><li><p><strong>有序性</strong></p><p>  保证同一时刻，代码是单线程执行的。因为<a href="%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%2018bc92bdc9e746ef8448c3c746876318.md"><strong>as-if-serial</strong></a>语义存在，但单线程的程序能保证最终结果是有序的。</p></li><li><p><strong>可重入性</strong></p><p>  是可重入锁，允许一个线程二次请求自己持有对象锁的临界资源，是可重入锁。synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。</p></li></ul><p><strong>synchronized的优势</strong></p><ul><li>自动获取锁</li><li>锁是可重入的互斥锁，即同一线程可以多次获得同一把锁，而且锁的释放只能由获得锁的线程来释放。Lock的锁就十分灵活</li><li>在低并发的情况下，synchronized的性能优于Lock</li></ul><p><strong>synchronized 锁升级的具体流程</strong></p><p><strong>MarkWord</strong>会记录锁的状态。包括<strong>哈希码、GC分代年龄、锁状态标志、偏向时间戳</strong>。</p><p><strong>1.无锁状态</strong> </p><p>当前无任何线程获取它，所以此过程不需要加锁，是无锁状态。当一个线程访问一个同步块时，如果该同步块没有被其他线程占用，那么该线程就可以直接进入同步块，并且将同步块标记为偏向锁状态。</p><p><strong>2.偏向锁状态</strong> </p><p>当第一个线程访问同步块的时候，锁会进入<strong>偏向模式</strong>。MarkWord会被设置为偏向模式。在偏向锁状态下，同步块已经被一个线程占用，其他线程访问该同步块时，只需要判断该同步块是否被当前线程占用，如果是，则直接进入同步块。这个过程不需要进行任何加锁操作，仍然属于乐观锁状态。</p><p><strong>3.轻量级锁状态</strong></p><p> 如果在偏向锁状态下，有多个线程竞争同一个同步块，那么该同步块就会升级为轻量级锁状态。此时，每个线程都会在自己的 CPU 缓存中保存该同步块的副本，并通过 CAS（Compare and Swap）操作来对同步块进行加锁和解锁。</p><p><strong>CAS</strong>操作会将对象头的MarkWord替换为指向锁记录的指针，如果成功，就获取轻量锁，如果失败，说明有竞争。</p><p>这个过程需要进行加锁操作，但相对于传统的 mutex 锁，轻量级锁的效率要高很多。</p><p><strong>4.重量级锁状态</strong> </p><p>轻量级锁之后会通过自旋来获取锁，自旋执行一定次数之后还未成功获取到锁，此时就会升级为重量级锁，并且进入阻塞状态。</p><p>重量级锁将对象头的MarkWord指向监视器<strong>Monitor对象</strong>来实现，该对象包含了锁的持有者、锁的等待队列等信息。</p><p>synchronized锁升级的过程可以有效的减少锁竞争，提高多线程的并发性。</p><p><img src="/.io//Untitled%203.png" alt="Untitled"></p><p><img src="/.io//Untitled%204.png" alt="Untitled"></p><h3 id="解决单例模式中懒汉式的线程安全问题"><a href="#解决单例模式中懒汉式的线程安全问题" class="headerlink" title="解决单例模式中懒汉式的线程安全问题"></a>解决单例模式中懒汉式的线程安全问题</h3><p>由于饿汉式不存在线程安全问题，所以只需要用同步机制来处理懒汉式存在的线程安全问题。</p><p>分别有三种方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Bank2 b1;</span><br><span class="line">    <span class="keyword">static</span> Bank2 b2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                b1=Bank2.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                b2=Bank2.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(b1);</span><br><span class="line">        System.out.println(b2);</span><br><span class="line">        System.out.println(b1==b2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            instance=<span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank2 instance=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Bank2.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    instance=<span class="keyword">new</span> <span class="title class_">Bank2</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对比与方式一 二 可能出现指令重排的问题</span></span><br><span class="line"><span class="comment">//从JDK2开始，分配空间、初始化、调用构造器会在线程的工作存储区一次性完成，然后复制到住存储去</span></span><br><span class="line"><span class="comment">//需要volatile关键字，避免指令重排的现象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank3</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank3</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Bank3 instance=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank3 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Bank3.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    instance=<span class="keyword">new</span> <span class="title class_">Bank3</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="关于死锁"><a href="#关于死锁" class="headerlink" title="关于死锁"></a>关于死锁</h3><p>不同资源分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，形成线程的死锁。</p><p><img src="/.io//Untitled%205.png" alt="Untitled"></p><p>关于诱发死锁的原因：</p><ul><li>存在互斥条件</li><li>占用且等待</li><li>不可抢夺或者不可抢占</li><li>循环等待</li></ul><p>同时出现上方四个条件就会触发死锁。</p><h3 id="如何解决死锁"><a href="#如何解决死锁" class="headerlink" title="如何解决死锁"></a>如何解决死锁</h3><p>只需要破坏上述条件之中的一个就可以避免死锁</p><ul><li>互斥条件基本上无法被破坏，因为线程需要通过互斥解决安全问题。</li><li>可以考虑一次性申请所有所需的资源，这样就不存在等待的问题</li><li>占用部分资源的线程在进一步申请其他资源的时候，如果申请不到，就主动释放已经占用的资源。</li><li>可以将资源改为线性，申请资源按序号顺序申请，避免循环等待。</li></ul><p>排查死锁：JDK自带一些性能工具，比如jps、jstack等。</p><p>也可以使用**<a href="../JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3%20d5060a3ae44143b2bcedbd4e92828014.md">可视化的性能工具</a>**，比如JConsole，VisualVM等。</p><h3 id="JDK5-0的新特性—Lock-锁"><a href="#JDK5-0的新特性—Lock-锁" class="headerlink" title="JDK5.0的新特性—Lock(锁)"></a>JDK5.0的新特性—Lock(锁)</h3><p>JDK5.0的新增功能，保证线程安全。与synchronized相比，Lock提供了<strong>多种锁的方案，更灵活强大（Lock通过方法来控制锁）</strong>。Lock通过显式定义同步锁对象来实现同步，同步锁使用Lock对象来充当。</p><p>Lock的步骤</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建lock的实例，需要确保多个线程共用一个Lock实例</span></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//执行lock方法</span></span><br><span class="line">lock.lock();</span><br><span class="line">｛线程不安全的代码部分｝&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">lock.unlock();<span class="comment">//保证执行解锁&#125;</span></span><br></pre></td></tr></table></figure><h3 id="关于线程之间的通信"><a href="#关于线程之间的通信" class="headerlink" title="关于线程之间的通信"></a>关于线程之间的通信</h3><p>在不同线程处理同一个任务的时候，往往需要有规律的执行，通过<strong>等待唤醒机</strong>制来协同多个线程进行工作，操作同一份数据。</p><p><strong>Obejct类</strong></p><ul><li><strong>wait(timeout)方法：阻塞线程的同时释放</strong></li><li><strong>notify()方法：唤醒当前wait中等级最高的一个线程 优先级相同就随机唤醒</strong></li><li><strong>notifyAll()方法： 唤醒被wait的所有线程</strong></li></ul><p><strong>这三个方法的应用必须在同步代码块或者同步方法中 调用者必须是同步代码块或者同步方法中的监视器（使用的类） 三个方法声明在Object中</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj);</span><br><span class="line">obj.notify();</span><br></pre></td></tr></table></figure><p><strong>Condition类</strong></p><ul><li><p>await():对应wait</p></li><li><p>singal&#x2F;signalAll 对应notify()</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Condition 对象</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition(); <span class="comment">// lock 下可创建多个 Condition</span></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 业务方法......</span></span><br><span class="line">    <span class="comment">// 1.进入等待状态</span></span><br><span class="line">    condition.await();</span><br><span class="line">    <span class="comment">// 2.唤醒操作</span></span><br><span class="line">    condition.signal();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Condition是Object的等待唤醒模型的升级，可以创建多个等待集，可以创建生产者等待唤醒对象，和一个消费者等待唤醒对象，实现生产者只能唤醒消费者，消费者只能唤醒生产者的业务逻辑了。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Condition 对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 生产者的 Condition 对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">producerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="comment">// 消费者的 Condition 对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">consumerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure></li></ul><p>tips：LockSupport无需配锁(synchronized或者Lock)一起使用。</p><p><strong>管道输入&#x2F;输出流</strong></p><p>管道输入&#x2F;输出流和普通文件输入输出或者网络输入&#x2F;输出流不同，主要用于线程之间的数据传输，而传输的媒介为内存。</p><p>管道的输入输出流主要包括如下四种具体实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter。前两种面向字节，后两种面向字符。</p><h3 id="wait与sleep的区别"><a href="#wait与sleep的区别" class="headerlink" title="wait与sleep的区别"></a><strong>wait与sleep的区别</strong></h3><ol><li><p><strong>声明位置的区别</strong></p><p> wait()声明在Object类当中，sleep()声明在Thread类之中，静态</p></li><li><p><strong>使用场景不同</strong></p><p> wait()只能使用在同步代码块和同步方法中，sleep()没有这方面的限制。</p></li><li><p><strong>对监视器的权限不同</strong></p><p> wait()进行阻塞之后会释放监视器，其他线程可以进行。sleep不会释放监视器。</p></li><li><p><strong>结束阻塞的方式不同</strong></p><p> wait()到达设定的timeout之后或者遇到notify被唤醒</p><p> sleep()到达设定的timeout之后唤醒。</p></li></ol><p>以上方法对线程的唤醒是随机的，想要制定唤醒线程可以使用LockSupport类。</p><ul><li>park()：休眠当前线程</li><li>unpark(线程对象)：唤醒某个指定的线程</li></ul><p><strong>Lock的介绍与使用</strong></p><p>Lock是一种线程同步机制，与synchronized相似，可以用于控制对共享资源的访问，更加灵活，支持更多的操作。</p><ul><li>lock() 获取锁，如果锁已被占用，则阻塞当前线程</li><li>tryLock() 尝试获取锁，如果锁已被其他线程占用，则返回false，否则返回true。</li><li>tryLock(long timeout, TimeUnit unit) 尝试获取锁，在指定的时间范围内获取到锁则返回true</li><li>unlock()释放锁</li></ul><p><strong>相比于synchronized，Lock的有优点在于</strong>：</p><ul><li><p><strong>粒度更细</strong>：synchronized只能对整个方法或者代码块进行同步，而Lock可以对单个变量或对象进行同步</p></li><li><p><strong>支持公平锁</strong>： Lock可以通过构造函数指定锁是否是公平锁。</p><ul><li><p><strong>非公平锁</strong></p><p>  不考虑等待时间的授予线程锁。</p></li><li><p><strong>公平锁</strong></p><p>  锁会授予等待时间最长的线程。</p></li></ul><p>  非公平锁在调用lock之后，首先会进行一次CAS抢锁，如果恰巧有锁，直接拿锁。</p><p>  非公平锁在CAS失败之后，会和公平锁一样都进入到<strong>tryAcquire</strong>方法，在tryAcquire方法中，如果锁被释放了，非公平直接CAS抢夺。公平锁会判断等待队列是否有排队的线程，有就去排队。</p><p>  相对来说非公平锁的性能更好，但是可能导致有线程长期处于饥饿状态。</p><p>  <img src="/.io//Untitled%206.png" alt="Untitled">  </p></li><li><p><strong>支持多个条件变量</strong>： Lock可以创建多个条件变量，即多个等待队列。</p></li><li><p><strong>ReentrantLock</strong>：提供了一种能够中断等待锁的线程的机制，通过<code>lock.lockInterruptibly()</code>来实现。默认<strong>非公平锁</strong>。</p></li><li><p><strong>ReentrantReadWriteLock 读写锁：</strong>读锁是共享锁，写锁是独占锁，读锁可以同时被多个线程持有，写锁只能被一个线程持有。这种锁的设计可以提高性能，特别是在读操作的数量远远超过写操作的情况下。</p></li></ul><p>Lock的实现类有很多，比较常用的有ReentrantLock和ReentrantReadWriteLock。使用Lock时需要手动获取和释放锁，否则会导致死锁等问题。一般使用try-finally确保锁的正确释放。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/.io//Untitled%207.png" alt="Untitled"></p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AbsractQueuedSynchronizer抽象同步队列，简称AQS，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。</p><p><img src="/.io//Untitled%208.png" alt="Untitled"></p><ul><li><p><strong>AQS</strong>是基于一个<strong>FIFO</strong>的双向队列，其内部定义了一个节点类Node，Node节点内部的<strong>SHARED</strong>用来标记该线程是获取共享资源时被阻挂起后放入AQS队列的。</p></li><li><p>AQS使用一个volatile修饰的int类型的成员变量<code>state</code>来表示同步状态，修改同步状态成功即为获得锁，<a href="%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%2018bc92bdc9e746ef8448c3c746876318.md">volatile</a>保证了变量在多线程之间的<strong>可见性</strong>，修改state值是通过CAS机制来保证修改的原子性。</p></li><li><p>获取state的方式分为两种，<strong>独占方式和共享方式</strong>，一个线程使用独占方式获取资源，其他线程就会在获取失败后被阻塞。一个线程使用共享方式获取资源，另一个线程还可以通过CAS进行获取。</p></li><li><p>如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS中会将竞争共享资源失败的线程添加到一个<strong>变体的CLH队列</strong>中。</p><p>  <img src="/.io//Untitled%209.png" alt="Untitled"></p><p>  上述的CLH是单向的，AQS队列是CLH变体等待队里拥有以下特性：</p><p>  <img src="/.io//Untitled%2010.png" alt="Untitled"></p><ul><li>AQS中队列是个双向链表，也是FIFO先进先出的特性。</li><li>通过Head、Tail头尾两个节点来组成队列结构，通过volatile修饰保证可见性。</li><li><strong>Head指向节点</strong>为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程。</li><li>获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数之后线程阻塞，相对CLH队列性能较好。</li></ul></li></ul><h3 id="ReetranLock实现原理"><a href="#ReetranLock实现原理" class="headerlink" title="ReetranLock实现原理"></a>ReetranLock实现原理</h3><p>ReentrantLock是可重入的<strong>独占锁</strong>，只能有一个线程可以获取该锁，其它获取该所的线程会被阻塞。</p><p>可重入表示当前线程获取该锁后再次获取不会被阻塞，也就意味着同一个线程可以多次获得同一个锁而<strong>不会发生死锁。</strong></p><p><strong>ReentrantLock的加锁和解锁</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建非公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 获取锁操作</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行代码逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁操作</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock通过一个内部计数器来跟踪锁的持有次数。当线程调用lock()方法获取锁时，ReentrantLock会检查当前状态，判断锁是否已经被其他线程持有。如果被持有，当前线程根据锁的公平性策略，可能会被加到等待队列中。</p><p>线程首次获得锁的时候，计数器变为1。调用unlock()的时候，持有锁的计数器-1，如果达到零，释放锁，唤醒等待队列。</p><p><img src="/.io//Untitled%2011.png" alt="Untitled"></p><p>上文一直提到CAS方式抢锁，那么什么是CAS呢？</p><h3 id="CompareAndSwap"><a href="#CompareAndSwap" class="headerlink" title="CompareAndSwap"></a>CompareAndSwap</h3><p>CAS比较并交换，主要通过处理器的指令来保证操作的原子性的。</p><p>CAS指令包含三个参数：共享变量的内存地址A、预期的值B和共享变量的新值C。</p><p>只有当内存中地址A处的值等于B时，才能将内存中地址A处的值更新为新值C。作为一条CPU指令，CAS指令本身是能够保证原子性的。</p><p><strong>CAS三大问题</strong></p><p><img src="/.io//Untitled%2012.png" alt="Untitled"></p><p><strong>ABA问题</strong></p><p>并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况，数据即使成功修改，也可能有问题。</p><p>解决ABA问题：版本号(类似乐观锁)</p><p>Java提供<strong>AtomicStampReference</strong>类，它的<strong>compareAndSet</strong>方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳Stamp的标志是否等于预期，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。</p><p><strong>循环性能开销</strong></p><p>自旋CAS会有性能消耗，所以通常会设置一个自旋次数的限制。</p><p><strong>只能保证一个变量的原子操作</strong></p><p>CAS保证的是对一个变量执行操作的原子性，如果，如果对多个变量操作时，CAS目前无法直接保证操作的原子性。</p><ul><li>可以考虑改用锁来保证操作的原子性</li><li>可以考虑合并多个变量，将多个变量封装成一个对象，通过<strong>AtomicReference</strong>来保证原子性。</li></ul><p><strong>Java中保证原子性的方法，例如保证多线程下i++的结果正确。</strong></p><p><img src="/.io//Untitled%2013.png" alt="Untitled"></p><ul><li><p>使用循环原子类，例如AtomicIntger，实现i++原子操作。</p><p>  <img src="/.io//Untitled%2014.png" alt="Untitled"></p></li><li><p>使用juc包下的锁，例如Reentrantlock，对i++操作加锁来实现原子性。</p></li><li><p>使用synchronized</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常见的线程池</title>
      <link href="/2024/04/21/%E5%B8%B8%E8%A7%81%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2024/04/21/%E5%B8%B8%E8%A7%81%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="常见四种线程池"><a href="#常见四种线程池" class="headerlink" title="常见四种线程池"></a>常见四种线程池</h1><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-71.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-71.png"></p><p>四大线程池</p><ul><li>newFixedThreadPool (固定数目线程的线程池)</li><li>newCachedThreadPool (可缓存线程的线程池)</li><li>newSingleThreadExecutor (单线程的线程池)</li><li>newScheduledThreadPool (定时及周期执行的线程池)</li></ul><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a><strong>SingleThreadExecutor</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>线程池特点</strong></p><ul><li>核心线程数为 1</li><li>最大线程数也为 1</li><li>阻塞队列是无界队列 LinkedBlockingQueue，可能会导致 OOM</li><li>keepAliveTime 为 0</li></ul><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-72.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-72.png"></p><p>SingleThreadExecutor运行流程</p><p>工作流程：</p><ul><li>提交任务</li><li>线程池是否有一条线程在，如果没有，新建线程执行任务</li><li>如果有，将任务加到阻塞队列</li><li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务。</li></ul><p><strong>适用场景</strong></p><p>适用于串行执行任务的场景，一个任务一个任务地执行。</p><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a><strong>FixedThreadPool</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>线程池特点：</strong></p><ul><li>核心线程数和最大线程数大小一样</li><li>没有所谓的非空闲时间，即 keepAliveTime 为 0</li><li>阻塞队列为无界队列 LinkedBlockingQueue，可能会导致 OOM</li></ul><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-73.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-73.png"></p><p>FixedThreadPool</p><p>工作流程：</p><ul><li>提交任务</li><li>如果线程数少于核心线程，创建核心线程执行任务</li><li>如果线程数等于核心线程，把任务添加到 LinkedBlockingQueue 阻塞队列</li><li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li></ul><p><strong>使用场景</strong></p><p>FixedThreadPool 适用于处理 CPU 密集型的任务，确保 CPU 在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a><strong>CachedThreadPool</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>线程池特点：</strong></p><ul><li>核心线程数为 0</li><li>最大线程数为 Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致 OOM</li><li>阻塞队列是 SynchronousQueue</li><li>非核心线程空闲存活时间为 60 秒</li></ul><p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-74.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-74.png"></p><p>CachedThreadPool执行流程</p><p>工作流程：</p><ul><li>提交任务</li><li>因为没有核心线程，所以任务直接加到 SynchronousQueue 队列。</li><li>判断是否有空闲线程，如果有，就去取出任务执行。</li><li>如果没有空闲线程，就新建一个线程执行。</li><li>执行完任务的线程，还可以存活 60 秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li></ul><p><strong>适用场景</strong></p><p>用于并发执行大量短期的小任务。</p><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a><strong>ScheduledThreadPool</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>线程池特点</strong></p><ul><li>最大线程数为 Integer.MAX_VALUE，也有 OOM 的风险</li><li>阻塞队列是 DelayedWorkQueue</li><li>keepAliveTime 为 0</li><li>scheduleAtFixedRate() ：按某种速率周期执行</li><li>scheduleWithFixedDelay()：在某个延迟后执行</li></ul><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-75.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-75.png"></p><p>ScheduledThreadPool执行流程</p><p><strong>工作机制</strong></p><ul><li>线程从 DelayQueue 中获取已到期的 ScheduledFutureTask（DelayQueue.take()）。到期任务是指 ScheduledFutureTask 的 time 大于等于当前时间。</li><li>线程执行这个 ScheduledFutureTask。</li><li>线程修改 ScheduledFutureTask 的 time 变量为下次将要被执行的时间。</li><li>线程把这个修改 time 之后的 ScheduledFutureTask 放回 DelayQueue 中（DelayQueue.add()）。</li></ul><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-76.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-76.png"></p><p>ScheduledThreadPoolExecutor执行流程</p><p><strong>使用场景</strong></p><p>周期性执行任务的场景，需要限制线程数量的场景</p><blockquote><p><strong>使用无界队列的线程池会导致什么问题吗</strong>？</p></blockquote><p>例如 newFixedThreadPool 使用了无界的阻塞队列 LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致 OOM。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/2024/04/21/%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/04/21/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><strong>线程与进程</strong></p><p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p><p>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p><p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。操作系统调度的最小任务单位其实不是进程，而是线程。</p><p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。</p><p><img src="/images/%E7%BA%BF%E7%A8%8B%20bf18de630f1940a9a2d9326552b07a91/Untitled.png" alt="Untitled"></p><p>具体采用哪种方式，要考虑到进程和线程的特点。</p><p><strong>和多线程相比，多进程的缺点在于：</strong></p><ul><li>创建进程比创建线程开销大，尤其是在Windows系统上；</li><li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li></ul><p>而多进程的优点在于：</p><p>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line"><span class="comment">//1.提供指定线程数量的线程池</span></span><br><span class="line">ExecutorService service= Executors.newFixedThreadPool(<span class="number">10</span><span class="comment">//线程数);</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line"><span class="comment">//设置线程池的属性</span></span><br><span class="line">service1.setMaximumPoolSize(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.执行指定的线程的操作，需要提供实现Runnable接口或者Callable接口实现类的对象</span></span><br><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());</span><br><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.关闭连接池</span></span><br><span class="line">service.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>初始状态：线程被创建，但还没有调用 start()方法</td></tr><tr><td>RUNNABLE</td><td>运行状态：Java 线程将操作系统中的就绪和运行两种状态笼统的称作“运行”</td></tr><tr><td>BLOCKED</td><td>阻塞状态：表示线程阻塞于锁</td></tr><tr><td>WAITING</td><td>等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td>TIME_WAITING</td><td>超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的</td></tr><tr><td>TERMINATED</td><td>终止状态：表示当前线程已经执行完毕</td></tr></tbody></table><p><img src="/images/%E7%BA%BF%E7%A8%8B%20bf18de630f1940a9a2d9326552b07a91/Untitled%201.png" alt="Untitled"></p><p><a href="%E7%BA%BF%E7%A8%8B%20bf18de630f1940a9a2d9326552b07a91/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%2069e0b22b84d240198f718892fe60f2cf.md">虚拟线程</a></p><p><a href="%E7%BA%BF%E7%A8%8B%20bf18de630f1940a9a2d9326552b07a91/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%20dcb7684e9bdc4e4d8e6f91b17b06fcfa.md">线程安全</a></p><p><a href="%E7%BA%BF%E7%A8%8B%20bf18de630f1940a9a2d9326552b07a91/%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%20246e18b99ee946b0949ab7b45698d705.md">线程创建方法</a></p><p><a href="%E7%BA%BF%E7%A8%8B%20bf18de630f1940a9a2d9326552b07a91/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%2018bc92bdc9e746ef8448c3c746876318.md">指令重排</a></p><p><a href="%E7%BA%BF%E7%A8%8B%20bf18de630f1940a9a2d9326552b07a91/ThreadLocal%204a508ec05f244d2487140cd0a25657e8.md">ThreadLocal</a></p><p><a href="%E7%BA%BF%E7%A8%8B%20bf18de630f1940a9a2d9326552b07a91/%E5%B8%B8%E8%A7%81%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%20e8570b67f440448fb3d0b55e52b2f0e0.md">常见四种线程池</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存</title>
      <link href="/2024/04/21/JVM%E5%86%85%E5%AD%98/"/>
      <url>/2024/04/21/JVM%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h1><h3 id="JVM的内存区域模型"><a href="#JVM的内存区域模型" class="headerlink" title="JVM的内存区域模型"></a>JVM的内存区域模型</h3><p><img src="/.io//Untitled.png" alt="Untitled"></p><p><strong>方法区和堆是线程共享区，虚拟机栈、程序计数器和本地方法栈是线程私有的。</strong></p><ul><li><p><strong>方法区</strong></p><p>  也称为永久代，非堆，用于存储虚拟机加载的类信息，常量，静态变量，是各个线程<strong>共享的内存区域。</strong></p><p>  运行时常量池：作为方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项关键信息就是常量池，用于存放编译器生成的各种符号的引用，这部分将在类加载后放到方法区的运行时常量池中。</p></li><li><p><strong>虚拟机栈</strong></p><p>  描述的是Java方法执行的内存模型，每个方法被执行的时候，都会创建一个<strong>栈帧</strong>用于存储局部变量，操作栈，方法出口等信息。每个<strong>方法</strong>被调用到执行完成的过程，就对应着一个<strong>栈帧</strong>在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。</p><p>  局部变量表：存放八种基本类型，对象引用，其中64位的long和double类型的数据会占用两个局部变量的空间。局部变量表是在编译时完成分配的，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，而且在运行的时候不会被改变。</p><p>  <img src="/.io//Untitled%201.png" alt="Untitled"></p></li><li><p><strong>本地方法栈</strong></p><p>  与虚拟机栈类似，为本地方法服务，为虚拟机使用到本地(Native)方法服务的。</p></li><li><p><strong>堆</strong></p><p>  java堆，GC堆。是JVM管理的内存中<strong>最大</strong>的一块内存区域，是线程共享的，随着JVM的启动创建。存放了对象的实例以及数组。</p><p>  <img src="/.io//Untitled%202.png" alt="Untitled"></p><p>  Permanent  Generation(方法区) 用来存放JVM自己的反射对象：类对象，方法对象等。</p><p>  如图可知JVM内存分为两大块，<strong>OLD</strong>(老年代)与<strong>NEW</strong>(新生代)；</p><p>  OLD用来存放应用程序中生命周期长的对象。</p><p>  NEW(新生代)分为Eden，From和To三个模块(8:1:1)。Eden(伊甸园)的空间，主要用来存放新生的对象，剩下的两个模块<strong>来源空间</strong>与<strong>目标空间</strong>用来存放每次垃圾回收后存活下来的对象。</p></li><li><p><strong>程序计数器</strong></p><p>  最小的一块内存，作用是当前线程所执行的字节码的型号指示器，在虚拟机的模型里面。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环。异常处理，线程恢复等基础功能都需要依赖计数器完成。</p></li><li><p><strong>直接内存</strong></p><p>  直接内存并不是虚拟机内存第一部分，也不是JVM规范中定义的内存区域。是本机内存。</p></li></ul><p><strong>堆与栈的区别</strong></p><p>堆线程共享，生命周期不由单个方法调用决定，可以在方法调用结束后继续存在。直到不被任何变量引用，然后被垃圾回收器回收。</p><p>栈线程私有，通常随着方法调用的结束而消失，无需进行垃圾收集。</p><h3 id="JDK1-6、1-7、1-8的内存区域变化"><a href="#JDK1-6、1-7、1-8的内存区域变化" class="headerlink" title="JDK1.6、1.7、1.8的内存区域变化"></a>JDK1.6、1.7、1.8的内存区域变化</h3><p>主要是体现在方法区的实现：</p><ul><li><p><strong>JDK1.6使用永久代实现方法区</strong></p><p>  <img src="/.io//Untitled%203.png" alt="Untitled"></p></li><li><p><strong>JDK1.7将字符串常量池、静态变量存放在堆上。</strong></p><p>  <img src="/.io//Untitled%204.png" alt="Untitled"></p></li><li><p><strong>JDK1.8取消永久代</strong></p><p>  在直接内存中划分出一块区域作为<strong>元空间</strong>，运行时常量池、类常量池都移动到元空间。</p><p>  <img src="/.io//Untitled%205.png" alt="Untitled"></p></li></ul><p><strong>为什么使用元空间替代永久代作为方法区实现</strong></p><p>Java虚拟机规范规定的 方法区只是换种方式实现。</p><ul><li>使用永久代来实现方法区的决定的设计导致Java应用更容易遇到内存溢出问题。因为永久代有上限，即使不设置也有默认大小。而J9和JRockit只要没有触碰到进程可用内存的上限，比如32位系统中的4GB限制，就不会出现问题，而极少数方法(Stirng::intern())会因永久代的原因导致不同虚拟机下有不同的表现。</li><li>主观上当 Oracle 收购 BEA 获得了 JRockit 的所有权后，准备把 JRockit 中的优秀功能，譬如 Java Mission Control 管理工具，移植到 HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到 HotSpot 未来的发展，在 JDK 6 的 时候 HotSpot 开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了 JDK 7 的 HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Meta-space）来代替，把 JDK 7 中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</li></ul><h3 id="什么是指针碰撞？什么是空闲列表？"><a href="#什么是指针碰撞？什么是空闲列表？" class="headerlink" title="什么是指针碰撞？什么是空闲列表？"></a><strong>什么是指针碰撞？什么是空闲列表？</strong></h3><p>内存分配有两种方式，<strong>指针碰撞</strong>（Bump The Pointer）、<strong>空闲列表</strong>（Free List）。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-10.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-10.png"></p><p><strong>指针碰撞和空闲列表</strong></p><ul><li><strong>指针碰撞</strong>：假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</li><li><strong>空闲列表</strong>：如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。</li></ul><p>两种方式的选择由 Java 堆是否<strong>规整</strong>决定，Java 堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的</p><h3 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h3><p><strong>内存泄露</strong>就是申请的内存空间没有被正确释放，导致内存被白白占用。</p><p><strong>内存溢出</strong>就是申请的内存超过了可用内存，内存不够了。</p><p>两者关系：内存泄露可能会导致内存溢出。</p><p>用一个有味道的比喻，内存溢出就是排队去蹲坑，发现没坑位了，内存泄漏，就是有人<strong>占着茅坑不拉屎</strong>，占着茅坑不拉屎的多了可能会导致坑位不够用</p><p><strong>创造几个内存溢出</strong></p><ul><li><p><strong>Java堆溢出</strong></p><p>  Java堆用于存储对象实例，只要不断创建不可回收的对象，比如静态对象，就可以造成OOM。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数： -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">OOMObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>虚拟机栈OOM</strong></p><p>  HotSPot的虚拟机的栈内存大小是固定的，可以不断创建线程，因为操作系统给每个进程分配的内存是有限的。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vm参数：-Xss2M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaVMStackOOM</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dontStop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stackLeakByThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">JavaVMStackOOM</span> <span class="variable">oom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaVMStackOOM</span>();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><strong>内存泄漏的原因</strong></p><p><img src="/.io//Untitled%206.png" alt="Untitled"></p><ul><li><p><strong>静态集合的内存泄漏</strong></p><p>  生命周期和JVM一致，所以引用了对象就不能释放。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOM</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oomTests</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">   list.add(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>单例模式</strong></p><p>  和上述例子类似，单例对象在初始化后以静态变量的方式在JVM的整个生命周期中还存在，如果单例对象持有外部的引用，那么这个外部的对象就不会被GC回收。</p></li><li><p><strong>数据连接、IO、Socket等连接</strong></p><p>  创建的连接不再使用时，要用close方法关闭连接。只有连接被关闭后，GC才会回收对应的对象(Connection,Statement,ResultSet,Session)。忘记关闭这些资源会导致持续占有内存，无法被GC回收。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    conn = DriverManager.getConnection(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//不关闭连接</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>变量不合理的作用域</strong></p><p>  一个变量的定义作用域大于其适用范围，很可能造成内存泄漏。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line">Object object;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">object = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">//...其他代码</span></span><br><span class="line"><span class="comment">//由于作用域原因，method1执行完成之后，object 对象所分配的内存不会马上释放</span></span><br><span class="line">object = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>hash值发生变化</strong></p><p>  hash值发生变化，无法找到存入的对象了，这也是为什么String类型被设置成了不可变类型。</p></li><li><p><strong>ThreadLocal使用不当</strong></p><p>  <strong>弱引用，要记得remove。</strong></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM的垃圾收集</title>
      <link href="/2024/04/21/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
      <url>/2024/04/21/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM的垃圾收集"><a href="#JVM的垃圾收集" class="headerlink" title="JVM的垃圾收集"></a>JVM的垃圾收集</h1><p><img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled.png" alt="Untitled"></p><p><strong>回收（GC）</strong>，顾名思义就是释放垃圾占用的空间，防止内存爆掉。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。</p><p>那在回收的时候，要弄清楚什么是垃圾、什么不是垃圾，这样就需要一种<strong>垃圾判断算法</strong>。</p><ul><li><p><strong>引用计数法</strong></p><p>  通过在对象头中分配一个空间来保存该对象被引用的次数。</p></li><li><p><strong>可达性分析法</strong></p><p>  通过一些被称为<strong>引用链</strong>(GC Roots)的对象作为起点，然后向下搜索，搜索走过的路径被称为Reference Chain，当一个对象到引用链之间没有任何引用相连时，即从引用链到该对象节点不可达，说明这个对象是需要垃圾收集的。</p><p>  <img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%201.png" alt="Untitled"></p></li></ul><p><strong>垃圾判断之后就是垃圾收集算法</strong></p><ul><li><p><strong>复制算法</strong></p><p>  使用复制算法，在进行垃圾回收的时候，回收器将存活对象从来源空间复制到目标空间，形成所有存活对象紧密排布的对列，分布在目标空间的一端，然后进行互换。</p><p>  <img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%202.png" alt="Untitled"></p><p>  实现：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">collect() &#123;</span><br><span class="line"><span class="comment">// 变量前面加*表示指针</span></span><br><span class="line"><span class="comment">// free指向TOSPACE半区的起始位置</span></span><br><span class="line">*free = *to_start;</span><br><span class="line"><span class="keyword">for</span>(root in Roots) &#123;</span><br><span class="line">copy(*free, root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换FROMSPACE和TOSPACE</span></span><br><span class="line">swap(*from_start,*to_start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  核心函数copy的实现：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">copy(*free,obj) &#123;</span><br><span class="line"><span class="comment">// 检查obj是否已经复制完成</span></span><br><span class="line"><span class="comment">// 这里的tag仅是一个逻辑上的域</span></span><br><span class="line"><span class="keyword">if</span>(obj.tag != COPIED) &#123;</span><br><span class="line"><span class="comment">// 将obj真正的复制到free指向的空间</span></span><br><span class="line">copy_data(*free,obj);</span><br><span class="line"><span class="comment">// 给obj.tag贴上COPIED这个标签</span></span><br><span class="line"><span class="comment">// 即使有多个指向obj的指针，obj也不会被复制多次</span></span><br><span class="line">obj.tag = COPIED;</span><br><span class="line"><span class="comment">// 复制完成后把对象的新地址存放在老对象的forwarding域中</span></span><br><span class="line">obj.forwarding = *free;</span><br><span class="line"><span class="comment">// 按照obj的长度将free指针向前移动</span></span><br><span class="line">*free += obj.size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归调用copy函数复制其关联的子对象</span></span><br><span class="line"><span class="keyword">for</span>(child <span class="title function_">ingetRefNode</span><span class="params">(obj.forwarding)</span>)&#123;</span><br><span class="line">*child = copy(*free,child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">returnobj.forwarding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这段代码中需要注意两个问题，其一是 tag&#x3D;COPIED 只是一个逻辑上的概念，用来区分对象是否已经完成复制，以确保即使这个对象被多次引用，也仅会复制一次；另外一个问题则是 forwarding 域， forwarding指针 在前面已经多次提到过，主要是用来保存对象移动后的新地址，比如在标记整理算法中，对象移动后需要遍历更新对象的引用关系，就需要使用 forwarding指针 来查找其移动后的地址，而在复制算法中，其作用类似，如果遇到已复制完成的对象，直接通过forwarding域把对象的新地址返回即可。整个复制算法的基本致流程如下图所示。</p><p>  <img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%203.png" alt="Untitled"></p><p>  调用根节点找到对象B</p><p>  <img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%204.png" alt="Untitled"></p><p>  B被复制后在目标空间中生成了B‘，B中的tag已经打上了COPIED的标签，forwarding指针中也存放了B’的地址。之后会对B引用的对象进行复制，复制结束后继续下一个根节点，直到全部复制。</p><p>  最后把FROM和TO进行互换，GC就结束了</p><p>  <img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%205.png" alt="Untitled"></p><p>  程序的搜索顺序是按照B、A、E进行搜索的，那就是说利用了深度优先算法。</p><p>  复制算法主要有如下优势：</p><ul><li><strong>吞吐量高</strong>：整个GC算法只搜索并复制存活对象，尤其是堆越大，差距越明显，毕竟它消耗的时间只是与活动对象数量成正比。</li><li><strong>可实现高速分配</strong>：由于GC完成后空闲空间是一个连续的内存块，在内存分配时，只要申请空间小于空闲内存块，只需要移动free指针即可。相较于标记-清理算法使用空闲链表的分配方式，复制算法明显快得多，毕竟要在空闲链表中找到合适大小的内存怎么都得遍历这个链表。</li><li><strong>无碎片</strong>：没啥好说的。</li><li><strong>与缓存兼容</strong>：可以回顾一下前面说的局部性原理，由于所有存活对象都紧密的排布在内存里，非常有利于CPU的高速缓存。</li></ul><p>  相较于前面的两种GC算法，其劣势主要有亮点：</p><ul><li><strong>堆空间利用率低</strong>：复制算法把堆一分为二，只有一半能被使用，内存利用率极低，这也是复制算法的最大缺陷。</li><li><strong>递归调用函数</strong>：复制某个对象时要递归复制它引用的对象，相较于迭代算法，递归的效率更低，而且有栈空间溢出的风险。</li></ul><p>  也可以使用<strong>Cheney复制算法</strong>，利用广度优先算法，改变的 是从一开始就把根节点包含的对象先复制到TO中，使用两个指针scan和free进行操作，每有一个类复制，free就移动，每有一个类中的引用类被全部引用，scan就移动到下一个类上，直到scan与free相遇。对比之前的算法，Cheney算法的优点是使用<strong>迭代算法</strong>代替<strong>递归</strong>，避免了栈的消耗和可能的栈溢出风险，特别是拿堆空间用作队列来实现广度优先遍历，非常巧妙。而缺点则是，相互引用的对象并不是相邻的，就没办法充分利用缓存。这里不一一描述。</p></li></ul><p><strong>标记清除MarkSweep</strong></p><p>先把内存区域中的这些对象进行标记，然后把标记为垃圾的对象进行清理。但是如下图所示，存在<strong>执行效率不稳定和内存空间碎片化</strong>问题。空间碎片化会导致当需要分配较大的对象时无法找到连续的足够内存而不得不再来一次GC。</p><p><img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%206.png" alt="Untitled"></p><p><strong>标记整理算法Mark-Compact</strong></p><p>标记过程仍然与标记清除算法一样，但是后续步骤不是直接进行清理，而是让所有存活的对象都向一端移动，再清理掉边界以外的内存区域。主要用于老年代。</p><p><img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%207.png" alt="Untitled"></p><p>在新生代中，每次垃圾回收时都发现有<strong>大批对象死去</strong>，只有少量存活，就选用复制算法，只需要付出少量存活对象的<strong>复制成本</strong>就可以完成收集。老年代中因为<strong>对象存活率高、没有额外空间对它进行分配担保</strong>，就必须使用标记清理或者标记整理算法来进行回收</p><p><strong>新生代GC（Minor GC&#x2F;Young GC）</strong>：<br>发生在新生代的垃圾回收动作，新创建的对象优先在新生代Eden区进行分配，如果Eden没有足够的空间，就会触发MinorGC。因为大多数对象都是朝生暮死的，所以Minor GC非常频繁，回收速度也比较快。</p><p>在Minor GC期间，如果年轻代中的对象幸存下来（即没有被回收），它们会被<strong>晋升</strong>到老年代中。这会增加老年代的内存占用。<br><strong>老年代GC(Major GC&#x2F;OLD GC)</strong><br>发生在老年代的GC，发生Full GC时，一般会伴随着一次Minor GC，Full GC的速度比较一般会比Minor GC慢10倍以上。<br><strong>混合GC(Mixed GC)</strong></p><p>指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</p><p><strong>整堆收集(Full GC)</strong></p><p>收集整个Java堆和方法区的垃圾收集。</p><p><img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%208.png" alt="Untitled"></p><ul><li><p><strong>YoungGC 之前检查老年代</strong></p><p>  因为YoungGC结束后会把存活的对象上升至老年代，所以如果发现老年代可用的连续内存空间＜新生代历次YoungGC后升入老年代的对象总和的平均大小，就会触发YoungGC</p></li><li><p><strong>Young之后老年代空间不足</strong></p></li><li><p><strong>老年代空间不足</strong></p><p>  老年代内存使用率过高，达到一定比例就会触发。</p></li><li><p><strong>方法区内存空间不足</strong></p><p>  如果方法区由永久代实现，空间不足FullGC</p></li><li><p><strong>System.gc()</strong></p></li></ul><p><strong>对象进入老年代</strong></p><p><img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%209.png" alt="Untitled"></p><p><strong>长期存活的对象进入老年代</strong></p><p>在对象的对象头信息中存储着对象的迭代年龄，迭代年龄会在每次YoungGC之后对象的移区操作中增加，每一次移区年龄加一。当这个年龄达到15(默认)之后，这对象将会被移入老年代。<br><code>- XX:MaxTenuringThreshold</code></p><p><strong>大对象直接进入老年代</strong></p><p>一些占用大量连续内存的空间对象会在被加载时就直接进入老年代。这样的大对象一般是一些数组，长字符串之类的对。</p><p>HotSpot提供了参数：</p><p><code>-XX：PretenureSizeThreshold</code></p><p><strong>动态对象年龄判定</strong></p><p>为了能更好地适应不同程序的内存状况，HotSpot 虚拟机并不是永远要求对象的年龄必须达到<code>- XX：MaxTenuringThreshold</code> 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><p><strong>空间分配担保</strong></p><p>假如在 Young GC 之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接送入老年代。</p><h3 id="引用链GC-Roots"><a href="#引用链GC-Roots" class="headerlink" title="引用链GC Roots"></a>引用链GC Roots</h3><p>所谓GC Roots，就是一组必须活跃的引用，不是对象，是程序运行时的起点，是一切引用链的源头，Java中的GCRoots有：</p><ul><li><p><strong>虚拟机栈中的引用(方法的参数、局部变量等)</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">// 这里的 localVar 是一个局部变量，存在于虚拟机栈中System.out.println(localVar.toString());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StackReference</span>().greet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  在 greet 方法中，localVar 是一个局部变量，存在于虚拟机栈中，可以被认为是 GC Roots。</p><p>  在 greet 方法执行期间，localVar 引用的对象是活跃的，因为它是从 GC Roots 可达的。</p><p>  当 greet 方法执行完毕后，localVar 的作用域结束，localVar 引用的 Object 对象不再由任何 GC Roots 引用（假设没有其他引用指向这个对象），因此它将有资格作为垃圾被回收掉</p></li><li><p><strong>本地方法栈中JNI的引用</strong></p><p>  Java通过JNI(Java Native Interface)提供了一种机制，允许Java代码调用本地代码，通常是C或者C++）</p><p>  当调用Java方法，虚拟机创建一个栈帧并压入虚拟机栈。当它调用本地方法时，虚拟机会通过动态链接直接调用指定的本地方法。</p><p>  <img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%2010.png" alt="Untitled"></p><p>  JNI 引用是在 Java 本地接口（JNI）代码中创建的引用，这些引用可以指向 Java 堆中的对象。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设的JNI方法public native void nativeMethod();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设在C/C++中实现的本地方法/*</span></span><br><span class="line"> * Class:     NativeExample</span><br><span class="line"> * Method:    nativeMethod</span><br><span class="line"> * Signature: ()V</span><br><span class="line"> */JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title function_">Java_NativeExample_nativeMethod</span><span class="params">(JNIEnv *env, jobject thisObj)</span> &#123;</span><br><span class="line">    <span class="type">jobject</span> <span class="variable">localRef</span> <span class="operator">=</span> (*env)-&gt;NewObject(env, ...);<span class="comment">// 在本地方法栈中创建JNI引用// localRef 引用的Java对象在本地方法执行期间是活跃的&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  在本地（C&#x2F;C++）代码中，localRef 是对 Java 对象的一个 JNI 引用，它在本地方法执行期间保持 Java 对象活跃，可以被认为是 GC Roots。</p><p>  一旦 JNI 方法执行完毕，除非这个引用是全局的（Global Reference），否则它指向的对象将会被作为<strong>垃圾回收掉</strong>（假设没有其他地方再引用这个对象）</p></li><li><p><strong>类静态变量</strong></p><p>  类静态变量可以被认为是GC Roots，只要类未被卸载，静态变量引用的对象就不会被垃圾回收。如果类被卸载，那么静态变量引用的对象也有资格被垃圾回收。</p></li><li><p><strong>运行时常量池中的常量</strong></p><p>  在运行时常量池中的常量存储可以作为GC Roots.这些常量引用的对象在常量池中，只要包含这些常量的类未被卸载，这些对象就不会被垃圾回收。</p></li></ul><p><strong>finalize()方法</strong></p><p>在对对象进行可达性分析之后发现没有跟GCRoots相连接的引用链，那他就会被第一次标记，然后进行一次筛选，条件是此对象是否有必要执行finalize()方法。如果对象在finalize中重新与引用链上的任何一个对象建立关联就行，比如把this关键字赋值给某个类变量或者对象的成员变量，那么在第二次标记时就不会被回收。</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>JVM的垃圾收集器主要分为两大类：分代收集器和分区收集器。分代收集器的代表是CMS，分区收集器的代表是G1和ZGC。</p><p>就目前来说，JVM 的垃圾收集器主要分为两大类：分代收集器和分区收集器，分代收集器的代表是 CMS，分区收集器的代表是 G1 和 ZGC。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-28.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-28.png"></p><p><strong>Serial 收集器</strong></p><p>Serial 收集器是最基础、历史最悠久的收集器。</p><p>如同它的名字（串行），它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。</p><p>Serial&#x2F;Serial Old 收集器的运行过程如图：</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-29.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-29.png"></p><p><strong>ParNew</strong></p><p>ParNew 收集器实质上是 Serial 收集器的多线程并行版本，使用多条线程进行垃圾收集。</p><p>ParNew&#x2F;Serial Old 收集器运行示意图如下：</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-30.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-30.png"></p><p><strong>Parallel Scavenge</strong></p><p>Parallel Scavenge 收集器是一款新生代收集器，基于<strong>标记-复制</strong>算法实现，也能够并行收集。和 ParNew 有些类似，但 Parallel Scavenge 主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是 CPU 用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-31.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-31.png"></p><p>根据对象存活周期的不同会将内存划分为几块，一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p><p><strong>Serial Old</strong></p><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p><p><strong>Parallel Old</strong></p><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-32.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-32.png"></p><p><strong>CMS收集器</strong></p><p>以获取最短回收停顿时间为目标，采用<strong>标记-清除</strong>算法，JDK9被弃用，14被清除。</p><p>CMS 收集齐的垃圾收集分为四步：</p><ul><li><strong>初始标记</strong>（CMS initial mark）：单线程运行，需要 Stop The World，标记 GC Roots 能直达的对象。</li><li><strong>并发标记</strong>（（CMS concurrent mark）：无停顿，和用户线程同时运行，从 GC Roots 直达对象开始遍历整个对象图。</li><li><strong>重新标记</strong>（CMS remark）：多线程运行，需要 Stop The World，标记并发标记阶段产生对象。</li><li><strong>并发清除</strong>（CMS concurrent sweep）：无停顿，和用户线程同时运行，清理掉标记阶段标记的死亡的对象。</li></ul><p>Concurrent Mark Sweep 收集器运行示意图如下：</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-34.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-34.png"></p><p><strong>G1(Garbage-First Garbage Collector)</strong></p><p>在JDK1.7被引入，在JDK9取代CMS成为默认的垃圾收集器。G1有五个属性：分代、增量、并行、标记整理、STW。</p><p><img src="/images/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81/Untitled%2011.png" alt="Untitled"></p><p>G1把连续的JAVA堆划分为多个大小相等的独立区域(Region)，每个Region都可以根据需要扮演Eden、Survivor或者老年代。收集器能对扮演不同角色的Region采用不同的策略去处理。</p><p>这样的好处是，避免了收集整个堆，而是按照若干个Region集进行收集，同时维护一个优先级列表，跟踪各个Region回收的价值，优先收集价值高的Region。</p><p>G1收集器的运行过程大致可以划分为下面四个步骤。</p><ul><li><strong>初始标记</strong>（initial mark），标记了从 GC Root 开始直接关联可达的对象。STW（Stop the World）执行。</li><li><strong>并发标记</strong>（concurrent marking），和用户线程并发执行，从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象、</li><li><strong>最终标记</strong>（Remark），STW，标记再并发标记过程中产生的垃圾。</li><li><strong>筛选回收</strong>（Live Data Counting And Evacuation），制定回收计划，选择多个 Region 构成回收集，把回收集中 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。需要 STW。</li></ul><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-36.png" alt="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-36.png"></p><p><strong>有了 CMS，为什么还要引入 G1</strong></p><p>优点：CMS 最主要的优点在名字上已经体现出来——并发收集、低停顿。</p><p>缺点：CMS 同样有三个明显的缺点。</p><ul><li>Mark Sweep 算法会导致内存碎片比较多</li><li>CMS 的并发能力比较依赖于 CPU 资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。</li><li>并发清除阶段，用户线程依然在运行，会产生所谓的理“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。</li></ul><p>G1 主要解决了内存碎片过多的问题。</p><p><strong>ZGC收集器</strong></p><p>ZGC是JDK11时引入的一款低延迟的垃圾收集器，目标是不超过10ms的停顿时间内，为堆大小达到16TB的应用提供一种高吞吐量的垃圾收集器。</p><p>ZGC的两个关键的技术：<strong>指针染色</strong>和<strong>读屏障</strong>，不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器要进行一次内存访问，并将对象的存活信息放在对象头中；而在ZGC中，只需要设置指针地址的<strong>第42-45位</strong>即可，并且因为是寄存器访问，所以速度比访问内存更快。</p><p><strong>STW STOP the World</strong></p><p>进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，这样的停顿被成为STW。</p><p>在HotSpot中有个数据结构(映射表)被称为OopMap。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。在即时编译过程中，也会在<strong>特定的位置</strong>生产OopMap，记录下栈上和寄存器里哪些位置是引用。</p><p>这些特定的位置主要存在于</p><ul><li>循环的末尾(非counted循环)</li><li>方法临返回前&#x2F;调用方法的call指令后</li><li>可能会抛异常的位置</li></ul><p>这些位置就叫做安全点。用户程序执行时并非在代码指令流的任意位置都能够停顿下来进行垃圾收集，而是必须执行到安全点才能够暂停。</p><h3 id="垃圾收集器的选择"><a href="#垃圾收集器的选择" class="headerlink" title="垃圾收集器的选择"></a>垃圾收集器的选择</h3><table><thead><tr><th>Serial</th><th>如果应用程序有个很小的内存空间(约为100MB)亦或他子啊没有停顿时间要求的单线程处理器上运行。</th></tr></thead><tbody><tr><td>Parallel</td><td>如果优先考虑应用程序的峰值性能，并且没有时间要求，可以接受一秒或更长的停顿时间</td></tr><tr><td>CMS&#x2F;G1</td><td>如果响应时间比吞吐量优先级高，或者垃圾收集暂停必须保持大约在一秒内。</td></tr><tr><td>ZGC</td><td>如果响应时间是高优先级，或者堆空间比较大。</td></tr></tbody></table><p><strong>JDK8默认的垃圾回收器</strong></p><p>使用命令行：</p><p><code>java -XX:+PrintCommandLineFlags -version</code></p><p>可以看到<br><code>-XX:+UseParallelGC</code></p><p>UseParallelGC表示的是Parallel Scavege+ Parallel Old。表示的是新生代用的Scavege收集器，老年代用的 是Parallel Old收集器。</p><p>Parallel Scavege特点：高吞吐、</p><p><strong>JKD17默认的垃圾回收器</strong></p><p> <code>-XX:+UseG1GC</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM的对象</title>
      <link href="/2024/04/21/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/04/21/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM的对象"><a href="#JVM的对象" class="headerlink" title="JVM的对象"></a>JVM的对象</h1><p>在JVM中创建对象，从一个new指令开始：</p><p><img src="/images/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1%20a905ae6050c248cd95e32a9961204e7e/Untitled.png" alt="Untitled"></p><ul><li>首先检查这个指令的参数是否能在常量池中定位到一个类的符号</li><li>检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有就执行相应的类加载</li><li>类加载检查通过后，接下来虚拟机将为新生对象分配内存。</li><li>内存分配完之后，虚拟机将分配到的内存空间(不包括对象头)都初始化为零值。</li><li>接下来设置对象头，请求头里包含了对象是哪个类的实例，如何找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。</li></ul><p><strong>类加载的过程</strong></p><p><img src="/images/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1%20a905ae6050c248cd95e32a9961204e7e/Untitled%201.png" alt="Untitled"></p><ul><li><p><strong>加载：查找并加载类的二进制数据</strong></p><p>   是类加载过程中的一个阶段，而不是类加载</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流锁代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.Lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul></li><li><p><strong>验证：确保被加载的类的正确性</strong></p><p>  验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合JVM的规范的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全。</p><ul><li>文件格式验证</li><li>字节码验证</li><li>符号引用验证</li></ul></li><li><p><strong>准备：为类的静态变量分配内存，并将其初始化为默认值</strong></p><p>  准备阶段是正式为类中定义的变量。(即静态变量，被static修饰的变量)，分配内存并设置类变量初始值的阶段，也就是加载这种代码的时候</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span></span><br></pre></td></tr></table></figure><p>  他的初始化的value为0，而非123。</p></li><li><p><strong>解析：把类中的符号引用转换为直接引用初始化，为类的静态变量赋予正确的初始值</strong></p></li><li><p><strong>使用：主动使用和被动使用</strong></p></li><li><p><strong>卸载：满足条件后，被GC回收</strong></p></li></ul><h3 id="JVM中new对象的线程安全"><a href="#JVM中new对象的线程安全" class="headerlink" title="JVM中new对象的线程安全"></a><strong>JVM中new对象的线程安全</strong></h3><p>在JVM中，每次new一个对象都会分配内存。当线程A正在给A对象分配内存的时候，指针还没来得及修改，线程B就引用这个指针来分配内存，发生指针抢占和线程安全问题。</p><p>解决的方法：</p><ul><li>采用<a href="../%E7%BA%BF%E7%A8%8B%20bf18de630f1940a9a2d9326552b07a91/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%20dcb7684e9bdc4e4d8e6f91b17b06fcfa.md">CAS</a>分配重试的方式来保证更新操作的原子性</li><li>每个线程在Java堆中预先分配一小块内存，也就是<strong>本地线程分配缓冲(Thread Local Allocation Buffer)TLAB</strong>,要分配内存的线程，先在本地缓冲区分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</li></ul><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在Java中，对象的内存布局是由Java虚拟机规范定义的，单具体的实现细节可能因为不同的JVM而不同。例如HotSpot、OpenJ9等。</p><p>在HotSpot中，对象在堆内存中的存储布局可以划分为三个部分:</p><p><img src="/images/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1%20a905ae6050c248cd95e32a9961204e7e/Untitled%202.png" alt="Untitled"></p><ul><li><p>对象头是每个对象都有的,主要包括三部分信息:</p><ul><li><strong>标记字(MarkWord)</strong> 包含了对象自身运行时的数据，如哈希码、垃圾回收分代年龄、锁状态标志、线程持有的锁、偏向线程ID等信息。在64位操作系统下占八个字节，32位操作系统下占4个字节。</li><li>**类型指针(Class Pointer)**：指向对象所属类的元数据的指针，JVM通过这个指针来确定对象的类。在开启了压缩指针的情况下，这个指针可以被压缩，压缩到了一半占4个字节。</li><li>**数组长度(Array Length)**：如果对象是数组类型，还会有一个额外的数组长度字段，占四个字节。</li></ul><p>  可以通过 <code>java -XX:+PrintFlagsFinal -version | grep UseCompressedOops</code> 命令来查看当前 JVM 是否开启了压缩指针。在JDK8中是默认开启。  </p></li><li><p><strong>实例数据</strong></p><p>  存储了对象的具体信息，即在类中定义的各种字段数据(不包括父类继承的字段)。这部分大小取决于对象的属性和它们的类型。JVM会对这些数据进行对齐，以确保高效的访问速度。</p></li><li><p><strong>对齐填充</strong></p><p>  为了使对象的总大小是8字节的倍数(这是大多数现代计算机体系结构中最优访问边界)，JVM可能会在对象末尾添加一些填充。这部分是为了满足内存对齐的需求。</p></li></ul><h3 id="那么为什么要8字节对齐呢"><a href="#那么为什么要8字节对齐呢" class="headerlink" title="那么为什么要8字节对齐呢"></a><strong>那么为什么要8字节对齐呢</strong></h3><p>这是因为CPU进行内存访问的时候，一次寻址的指针大小是8字节，正好是L1缓存行的大小。如果不进行内存对齐，则可能出现跨缓存行访问，导致额外的缓存行加载，降低访问效率。</p><p><img src="https://cdn.tobebetterjavaer.com/stutymore/jvm-20240320222058.png" alt="https://cdn.tobebetterjavaer.com/stutymore/jvm-20240320222058.png"></p><p>比如说上图中 obj1 占 6 个字节，由于没有对齐，导致这一行缓存中多了 2 个字节 obj2 的数据，当 CPU 访问 obj2 的时候，就会导致缓存行的刷新，这就是缓存行污染。</p><p>也就说，8 字节对齐，是为了效率的提高，以空间换时间的一种方案。固然你还能够 16 字节对齐，可是 8 字节是最优选择。</p><p><strong>那么new一个Object()的大小是多少</strong></p><p>对象的大小是由对象头、实例数据和对其填充这三个部分组成的。</p><ul><li>对象头32位是8字节 64位上是12(默认压缩)</li><li>对于new的Object来说，实例数据可以视为0</li><li>对齐填充的大小取决于对象头和实例数据大小，确保对象的大小是8的倍数。</li></ul><p>所以在64位的JDK8的JVM上，一个new的Object是12字节头+4字节的对齐填充一共16字节。</p><p><strong>对象怎么访问定位</strong></p><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《JVM规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问堆中对象的具体位置。</p><p>主流的方式主要有使用<strong>句柄和直接指针</strong>两种。</p><ul><li><p><strong>使用句柄访问</strong></p><p>  Java堆中划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。</p></li></ul><p><img src="/images/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1%20a905ae6050c248cd95e32a9961204e7e/Untitled%203.png" alt="Untitled"></p><ul><li><p><strong>使用直接指针访问</strong></p><p>  Java堆中对象的内存布局必须考虑如何放置访问类型数据的相关信息。reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</p><p>  <img src="/images/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1%20a905ae6050c248cd95e32a9961204e7e/Untitled%204.png" alt="Untitled"></p><p>  <strong>句柄</strong>的好处是即使对象在垃圾收集的时候被移动的时候只需要改变句柄中的实例数据指针，reference不需要修改，比较稳定。</p><p>  <strong>直接指针</strong>的最大好处是速度快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是极为可观的执行成本。</p><p>  <strong>HotSpot虚拟主要使用直接指针。</strong></p></li></ul><p><strong>如何判断对象是否存活</strong></p><p><a href="JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%20b4087de82bda433db5dd89ad4f070f81.md">引用计数和可达性</a></p><p><strong>对象的访问和对象的引用强度</strong></p><p>对象的访问涉及到java栈，java堆，方法区三个内存区域。</p><p>在JVM的访问方式使用的是指针访问方式。</p><p><img src="/images/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1%20a905ae6050c248cd95e32a9961204e7e/Untitled%205.png" alt="Untitled"></p><p><strong>对象的引用强度</strong></p><ul><li><p><strong>强引用</strong></p><p>  类似 Object object &#x3D; new Object()这种引用，只要强引用还存在，就永远不会被GC清除。</p></li><li><p><strong>软引用</strong></p><p>  用来描述一些还有用但是并非必须存在的对象，在JVM内存不足的时候会被GC回收。通过<strong>SoftReference</strong>来实现软引用，SoftReference很适合用于实现缓存。当GC扫描的软引用不经常使用时也会进行回收，可用softReference.get()获取。</p></li><li><p><strong>弱引用</strong></p><p>  弱引用也是用来描述一些还有用但是非必要的对象，强度会比软引用更加弱些。被弱引用关联的对象，生命周期只有一次GC。JDK通过WeakReference类来实现。当获取时，可以通过get方法获取，可能返回的是null。</p><p>  可传入一个ReferenceQueue对象到WeakReference构造，当引用对象被表示可回收时，isEnqueued会返回true。</p></li><li><p><strong>虚引用</strong></p><p>  又称为幻影引用，是最弱的一种引用关系。虚引用的作用是希望能在被GC回收的时候获得一个系统通知。可以通过PhantomReference类来实现。get方法永远返回null，当user从内存中删除时，调用isEnqueued会返回true。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>注释/API文档</title>
      <link href="/2024/04/21/%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3/"/>
      <url>/2024/04/21/%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="注释-API文档"><a href="#注释-API文档" class="headerlink" title="注释&#x2F;API文档"></a>注释&#x2F;API文档</h1><h3 id="除了单行注释和多行注释外，JAVA提供了一种文档注释。"><a href="#除了单行注释和多行注释外，JAVA提供了一种文档注释。" class="headerlink" title="除了单行注释和多行注释外，JAVA提供了一种文档注释。"></a>除了单行注释和多行注释外，JAVA提供了一种文档注释。</h3><p><strong>文档注释内容</strong>可以被JDK提供的工具<strong>javadoc</strong>所解析，生成一套以网页文件形式体现的该程序的说明文档。</p><p>文档注释的形式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>操作方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javadoc -d mydoc -author -version HelloWorld.java</span><br></pre></td></tr></table></figure><p>class需要为<strong>public</strong> ，执行之后会在本文件夹中生成一个新的文件夹mydir。在里面的<strong>index.html</strong>就是生成的程序说明文档。 </p><p>如果出现乱码，将编码模式改为GBK。</p><h2 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h2><p>**API(Application Programming Interface,应用程序接口)**是java提供的基本编程接口。</p><p>Java语言里面提供了大量的基础类，因此Oracle也为这些基础类提供相应 的说明文档，用于告诉开发如何使用这些类。</p><p>JAVA API文档，即为<strong>JDK的使用说明书</strong>。</p><p>在线API文档：</p><blockquote><p><a href="https://docs.oracle.com/en/java/javase/17/docs/api/index.html">https://docs.oracle.com/en/java/javase/17/docs/api/index.html</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM与注释&#92;API文档</title>
      <link href="/2024/04/21/JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3/"/>
      <url>/2024/04/21/JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM与注释-API文档"><a href="#JVM与注释-API文档" class="headerlink" title="JVM与注释\API文档"></a>JVM与注释\API文档</h1><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><strong>JVM的组织架构</strong></p><p><img src="/images/JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3%20d5060a3ae44143b2bcedbd4e92828014/Untitled.png" alt="Untitled"></p><p><strong>类加载器</strong></p><p>负责从文件系统、网络或者其他来源加载Class文件，将Class文件中的二进制数据读到内存中。</p><p><strong>运行时数据区</strong></p><p>JVM在执行Java程序时，需要在内存中分配空间来处理各种数据，在这些内存区域主要包括方法区、堆、栈、程序计数器和本地方法栈。</p><p><strong>执行引擎</strong></p><p>执行引擎是JVM的心脏，负责执行字节码。它包括一个虚拟处理器，还包括即时编译器JIT和垃圾回收期GC</p><h3 id="Java的优点"><a href="#Java的优点" class="headerlink" title="Java的优点"></a>Java的优点</h3><ol><li><p><strong>跨平台性:</strong> </p><p> java的核心优势，在最初设计的时候就很注重移植和跨平台性，比如：Java中的int永远是32位。</p><p> 因为虚拟机的存在，执行程序都是有虚拟机来保证程序在当前系统中的运行。</p></li><li><p><strong>面向对象性</strong></p><p> 面向对象是一种程序设计技术，非常适合大型软件的设计和开发。面向对象支持封装、继承、多态等特性，达到高聚合低耦合的标准。</p></li><li><p><strong>健壮性</strong></p><p>除了继承c&#x2F;c++的优点外，去掉了指针、内存的申请与释放等，提供了一个相对安全的内存管理和访问机制。</p></li><li><p><strong>安全性高</strong></p><p> Java适用于网络&#x2F;分布环境，需要提供一个安全机制以防恶意代码攻击，如安全防范机制（ClassLoader类加载器），可以分配不同的命名空间以防代替本地的同名类、字节代码检查。</p></li><li><p><strong>支持多线程</strong></p><p> C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能。而Java支持多线程操作。</p></li><li><p><strong>编译与解释并存</strong></p><p> 高级编程语言按照程序执行的方式分为<strong>编译型</strong>和<strong>解释型</strong>。编译型是至编译器针对特定的操作系统将源代码一次性翻译成可以被该平台执行的机器码。解释型是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</p><p> 编译型主要有<strong>C++、C、Swift、Rust</strong>等这些语言在编译时，会检查所有的语法和语义错误，因此，一旦编译成功，运行时通常具有较高的执行效率。但是，编译型语言的<strong>缺点</strong>在于，如果源代码发生变动，通常需要重新编译整个程序。</p><p> 解释型语言主要有<strong>JavaScript、Perl、Python、Ruby</strong>等。解释型语言的<strong>优点</strong>在于，开发过程灵活，代码修改后可以直接运行，无需重新编译整个程序。然而，由于解释型语言在运行时需要逐行解释源代码，因此执行效率通常较低。</p></li></ol><h3 id="JVM-JDK-与JRE"><a href="#JVM-JDK-与JRE" class="headerlink" title="JVM JDK 与JRE"></a>JVM JDK 与JRE</h3><p><strong>JVM</strong></p><p>Java的虚拟机，Java程序运行在JVM上，针对不同的系统都可以实现</p><p><strong>JRE</strong></p><p>Java的运行环境，是运行已编译Java程序所需的所有内容的合集，包括JVM、Java类库，Java命令和其他的一些基础构件，但是，不能用于创建新程序。</p><p><strong>JDK</strong></p><p>功能齐全的JavaSDK，拥有JRE拥有的一切，还有编译器Javac和工具javadoc、jdb等，讷讷感狗创建和编译程序。</p><p><strong>JDK&gt;JRE&gt;JVM</strong></p><p><img src="/images/JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3%20d5060a3ae44143b2bcedbd4e92828014/Untitled%201.png" alt="Untitled"></p><h3 id="JVM功能说明"><a href="#JVM功能说明" class="headerlink" title="JVM功能说明"></a>JVM功能说明</h3><p><strong>JVM具有强大的功能</strong>：</p><p><strong>功能1：实现Java程序的跨平台性</strong>。</p><p>Java程序在经过编译之类产生的.class文件，就是<strong>字节码</strong>。字节码能够被虚拟机识别，实现跨平台性。</p><p>Java程序从源代码到运行主要有<strong>三步</strong>：</p><ul><li>编译：将java代码编译成虚拟机可以理解 的字节码</li><li>解释：虚拟机将字节码翻译成机器码</li><li>执行：对应机器执行二进制机器码。</li></ul><p><img src="/images/JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3%20d5060a3ae44143b2bcedbd4e92828014/Untitled%202.png" alt="Untitled"></p><p><strong>功能2：自动内存管理（内存分配、内存回收</strong>）</p><pre><code>   涉及到运算的数据分配和存储都是有JVM来完成。JVM的存在消除人为回收无用内存空间的职责，提供一种系统级线程跟踪存储空间的分配情况，在空间达到相应的阈值的时候，检查释放可被释放的存储器空间，很大程度上减少了因为空间问题造成的内存泄漏</code></pre><p><strong>那Java还会出现内存溢出和内存泄漏吗？</strong></p><p>答案是会的。</p><p><strong>在JVM的底层，我们可以将其分为以下几个主要部分：</strong></p><ol><li><strong>硬件平台</strong>：JVM运行在特定的硬件平台上，如x86、ARM等。硬件平台提供了基础的计算、存储和I&#x2F;O能力，JVM需要利用这些能力来执行Java字节码。</li><li><strong>操作系统</strong>：操作系统是JVM的直接运行环境。操作系统提供了进程管理、内存管理、文件系统、网络通信等功能，JVM需要依赖这些功能来提供Java应用程序的运行环境。例如，JVM通过操作系统的内存管理功能来分配和回收内存，通过文件系统功能来加载和保存类文件等。</li><li><strong>JVM内核</strong>：JVM内核是JVM的核心部分，它负责执行Java字节码，提供Java应用程序的运行环境。JVM内核包括解释器、JIT编译器、垃圾回收器、类加载器等关键组件。<ul><li><strong>解释器</strong>：解释器负责逐条解释执行Java字节码。</li><li><strong>JIT编译器</strong>：JIT（Just-In-Time）编译器负责将Java字节码编译成本地机器码，以提高执行效率。</li><li><strong>垃圾回收器</strong>：垃圾回收器负责自动管理Java应用程序的内存，回收不再使用的对象占用的内存空间。</li><li><strong>类加载器</strong>：类加载器负责加载Java类文件到JVM中，为执行Java字节码提供基础。</li></ul></li><li><strong>Java类库</strong>：Java类库是JVM提供的一组标准库，它提供了许多常用的功能和接口，如文件操作、网络编程、数据库连接等。Java应用程序可以直接使用这些类和接口，而无需关心底层的实现细节。</li></ol><p><strong>内存调优</strong></p><p>原因：过多的GC和Full GC是会占用很多的系统资源，影响系统的吞吐量。</p><p>目的：减少Full GC次数，减少GC频率，尽量降低CG所导致的应用线程暂停时间。</p><p>手段：主要是针对内存管理方面发调优，包括各个代的大小，GC策略。</p><ul><li><p><strong>内存控制</strong></p><ul><li><p>OLD空间不足</p><p>  调优的时候尽量让对象在NEW被GC回收，让对象在新生代多存活一段时间和不要创建过大的对象记忆数组避免直接在旧生代创建对象</p></li><li><p>Pemanet Generation空间不足</p><p>  增大空间，避免太多静态对象</p></li><li><p>统计得到的GC后晋升到旧生代的平均大小大于旧生代剩余空间</p><p>  控制好新生代和旧生代比例</p></li><li><p>System.gc()被显示调用</p><p>  垃圾回收不要手动触发，尽量依靠JVM自身的机制</p></li></ul></li><li><p><strong>控制堆内存的各个部分的比例和GC策略失调</strong></p><ul><li><p>新生代设置过小</p><p>  一是GC次数频繁增大消耗，二是大对象被写入旧生代，诱发FullGC。</p></li><li><p>新生代设置过大</p><p>  一是新生代设置过大挤压旧生代的内存空间，诱发FullGC；二是新生代GC消耗大幅度增加。一般来说新生代占整个堆1&#x2F;3比较合适。</p></li><li><p>Survivor设置过小</p><p>  导致对象从eden直接到达旧生代，降低新生代存活时间。</p></li><li><p>Survivor设置过大</p><p>  导致eden过小，降低在新生代的存活时间</p></li><li><p>新生代存活时间太少</p><p>  通过-XX：MaxTenuringThreshold&#x3D;n来控制新生代的存活时间，尽量让对象在新生代被回收。</p></li></ul></li></ul><p><strong>GC策略</strong></p><ul><li><p><strong>吞吐量优先</strong></p><p>  JVM以吞吐量为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，来达到吞吐量指标。这个值可由-XX:GCTimeRatio&#x3D;n来设置</p></li><li><p><strong>暂停时间优先</strong></p><p>  JVM以暂停时间为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，尽量保证每次GC造成的应用停止时间都在指定的数值范围内完成。这个值可由-XX:MaxGCPauseRatio&#x3D;n来设置</p></li></ul><p><strong>JVM常见配置</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、堆设置</span><br><span class="line">-Xms:初始堆大小</span><br><span class="line">-Xmx:最大堆大小</span><br><span class="line">-XX:NewSize=n:设置年轻代大小</span><br><span class="line">-XX:NewRatio=n:设置年轻代和年老代的比值。如:为<span class="number">3</span>，表示年轻代与年老代比值为<span class="number">1</span>：<span class="number">3</span>，年轻代占整个年轻代年老代和的<span class="number">1</span>/<span class="number">4</span></span><br><span class="line">-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：<span class="number">3</span>，表示Eden：Survivor=<span class="number">3</span>：<span class="number">2</span>，一个Survivor区占整个年轻代的<span class="number">1</span>/<span class="number">5</span></span><br><span class="line">-XX:MaxPermSize=n:设置持久代大小</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、收集器设置</span><br><span class="line">-XX:+UseSerialGC:设置串行收集器</span><br><span class="line">-XX:+UseParallelGC:设置并行收集器</span><br><span class="line">-XX:+UseParalledlOldGC:设置并行年老代收集器</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、垃圾回收统计信息</span><br><span class="line">-XX:+PrintGC</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-Xloggc:filename</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、并行收集器设置</span><br><span class="line">-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</span><br><span class="line">-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、并发收集器设置</span><br><span class="line">-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</span><br><span class="line">-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</span><br><span class="line">注意:在对JVM内存调优的时候不能只看操作系统级别Java进程所占用的内存，这个数值不能准确的反应堆内存的真实占用情况，因为GC过后这个值是不会变化的，因此内存调优的时候要更多地使用JDK提供的内存查看工具，比如JConsole和Java VisualVM。</span><br></pre></td></tr></table></figure><p><strong>调优工具</strong>：</p><p><img src="/images/JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3%20d5060a3ae44143b2bcedbd4e92828014/Untitled%203.png" alt="Untitled"></p><p><strong>JDK可视化监控工具</strong></p><p>JConsole 在bin目录下，自动后自动搜索jvm进程，不需要指定。</p><p>是一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。用java写的GUI程序，用来监控VM，并可监控远程的VM，非常易用，而且功能非常强。</p><p>在cmd里面输入 jconsole，选则进程就可以了。<br>有概述，内存，线程，类，VM摘要和Mbean六个页签。<br>概述:显示有关JVM的监测值</p><p>内存: 显示内存使用信息</p><p>注意垃圾回收次数、时间、以及partial GC和full GC</p><p>线程: 显示线程使用信息</p><p>类: 显示类装载信息</p><p>VM摘要:显示java VM信息</p><p>MBeans: 显示 MBeans.</p><p><strong>ClassLoader的加载原理</strong></p><p>ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），当父亲已经加载了该类的时候，子ClassLoader不再加载，避免了重复加载。<br>双亲委派模型的工作工程：当一个类加载器收到一个类加载请求时，它首先不会先去加载这个类，而是把这个请求委托给<strong>父加载器</strong>，每一层的加载器都是如此，所以最终所有的加载请求都会传送到最上层的启动加载器。只有当父加载器反馈自己无法完成加载请求（它管理的范围之中没有这个类），子加载器才会尝试自己去加载。</p><p><a href="https://hyw20010212.github.io/2024/04/21/%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3/">注释&#x2F;API文档</a></p><p><a href="https://hyw20010212.github.io/2024/04/21/JVM%E5%86%85%E5%AD%98/">JVM内存</a></p><p><a href="https://hyw20010212.github.io/2024/04/21/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/">JVM的垃圾收集</a></p><p><a href="https://hyw20010212.github.io/2024/04/21/JVM%E7%9A%84%E5%AF%B9%E8%B1%A1/">JVM的对象</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>File类与IO流</title>
      <link href="/2024/04/17/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/"/>
      <url>/2024/04/17/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="File类与IO流"><a href="#File类与IO流" class="headerlink" title="File类与IO流"></a>File类与IO流</h1><p><strong>File类的理解</strong></p><p>File类位于java.io包下，File类的一个对象，对应与操作系统下的一个文件或一个文件目录（或文件夹）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String pathname)</span>;<span class="comment">//以pathname为路径创建File对象，可以是相对路径也可以是绝对路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String parent, String child)</span>;<span class="comment">//以parent为父路径，child为子路径创建File对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(File parent, String child)</span>;<span class="comment">//根据一个父File对象和子文件路径创造File对象</span></span><br></pre></td></tr></table></figure><p><strong>获取文件和目录的基本信息</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span><span class="comment">//获取名称</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span><span class="comment">//获取路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAbsolutePath</span><span class="params">()</span><span class="comment">//获取绝对路径</span></span><br><span class="line"><span class="keyword">public</span> File <span class="title function_">getAbsoluteFile</span><span class="params">()</span><span class="comment">//获取绝对路径表示的文件</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getParent</span><span class="params">()</span><span class="comment">//获取上层文件目录路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">length</span><span class="params">()</span><span class="comment">//获取文件的字节数，目录不行</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lastModified</span><span class="params">()</span><span class="comment">//获取最后一次修改时间</span></span><br><span class="line"><span class="keyword">public</span> String[] list()<span class="comment">//返回一个String数组，表示该Fiel目录中的所有子文件或目录</span></span><br><span class="line"><span class="keyword">public</span> File[] listFiles()<span class="comment">//返回一个File数组，表示该File目录中所有的子文件或者目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">renameTo</span><span class="params">(File dest)</span><span class="comment">//把文件重命名为指定的文件路径</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>Windows平台使用\ 在Java字符串中需要用\表示一个,Linux平台使用&#x2F;作为路径分隔符</p><p><strong>判断功能的方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span> <span class="comment">//此File表示的文件或目录是否实际存在</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span><span class="comment">//此File表示的是否为目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span><span class="comment">//此File表示的是否为文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canRead</span><span class="params">()</span><span class="comment">//判断是否可读</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWrite</span><span class="params">()</span><span class="comment">//判断是否可写入</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHidden</span><span class="params">()</span><span class="comment">//判断是否隐藏</span></span><br></pre></td></tr></table></figure><p><strong>创建与删除功能</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span><span class="comment">//创建文件</span></span><br><span class="line"><span class="keyword">public</span> File <span class="title function_">createTempFile</span><span class="params">()</span><span class="comment">//创建临时文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteOnExit</span><span class="params">()</span><span class="comment">//在JVM退出的时候自动删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdir</span><span class="params">()</span><span class="comment">//创建文件目录，如果存在或上层目录不存在，就不创建了</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span><span class="comment">//创建文件目录，如果上层文件目录不存在，一并创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span><span class="comment">//删除文件或者文件夹</span></span><br><span class="line">删除的注意事项：</span><br><span class="line"><span class="number">1.</span>Java中的删除不走回收站</span><br><span class="line"><span class="number">2.</span>删除一个文件目录，注意该文件目录内不能包含文件或者文件目录（干净的目录）</span><br></pre></td></tr></table></figure><p><strong>过滤函数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] listFiles = file.list(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File file, String name)</span>&#123;</span><br><span class="line"><span class="comment">//判断语句</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>File类中声明了以上各种功能，但是没有涉及到文件内容的读写操作，想要实现文件内容的读写，就需要使用IO流。File的对象，通常是作为IO流操作的文件的端点出现的。</p><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p><img src="/images/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%20ffd098987fc940b08165bbe1afeae826/Untitled.png" alt="Untitled"></p><p><strong>IO流</strong>分为输入流<strong>InputStream</strong>和输出流<strong>OutputStream</strong></p><p><strong>InputStream</strong></p><p>InputStream是Java标准库中提供的最基本的输入流，位于java.io这个包里面。InputStream不是一个接口，而是一个抽象类，是所有输入流的超类。</p><p>InputStream提供了read()的方法，用来读取文件的字节，并用返回字节表示的int值，如果读取完毕，就返回-1。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建一个FileInputStream对象:</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n); <span class="comment">// 打印byte的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    input.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputStream和OutputStream都是通过close()方法来关闭流，释放对应的底层资源。</p><p>使用try-catch来保证释放流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123; <span class="comment">// 利用while同时读取并判断</span></span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input != <span class="literal">null</span>) &#123; input.close(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>try ... finally</code>来编写上述代码会感觉比较复杂，更好的写法是利用Java 7引入的新的<code>try(resource)</code>的语法，只需要编写<code>try</code>语句，让编译器自动为我们关闭资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在读取字符的时候单个读取效率很低，可以使用缓冲区一次性读取多个字节，提高效率。InputStream提供了连个重载的方法来支持读取多个字节。</p><ul><li>int read(byte[] b)</li><li>int read(byte[] b, int off, intr len) 指定byte[]数组的起点和最大填充数。</li></ul><p>定义byte[]数组作为read()方法的入参，byte数组的长度限定了read方法读取字节的最大长度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((bytesRead = input.read(buffer, <span class="number">0</span>, buffer.length)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="comment">// 处理读取到的数据  </span></span><br><span class="line">                <span class="comment">// 例如，可以将其写入文件或输出到控制台  </span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>在测试的时候，不需要在本地真得建立一个txt，使用InputStream的子类的ByteArryInputStream来构造一个Stream来进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> readAsString(input);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readAsString</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sb.append((<span class="type">char</span>) n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>OutputStream</strong></p><p>OutputStream是Java提供的最基本的输出流，与InputStream类似，它是所有输出流的超类，重要的方法是write(int i)，虽然传参是int类型，但是只会写入一个字节，即只写入int表示的最低8为的字节的部分。</p><p>OutputStream还提供了flush()方法，将缓冲区的内容真正的输出到目的地。</p><p>每次写入一个字节的方法非常麻烦，OutputStream提供了重载方法write(byte [])来实现多数据输出。避免磁盘已满，无权限写入等问题，类似的，我们使用try(resource)来保证OutputStream是否发生IO错误的时候都能够正确地关闭。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line"><span class="keyword">try</span>(<span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;name:&quot;</span>))&#123;</span><br><span class="line">out.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时操作多个<code>AutoCloseable</code>资源时，在<code>try(resource) &#123; ... &#125;</code>语句中可以同时写出多个资源，用<code>;</code>隔开。例如，同时读写两个文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取input.txt，写入output.txt:</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">     <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    input.transferTo(output); <span class="comment">// transferTo的作用是?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transferTo等同于以下的循环操作，但是更为高效：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 假设使用1024字节的缓冲区  </span></span><br><span class="line"><span class="type">int</span> bytesRead;  </span><br><span class="line"><span class="keyword">while</span> ((bytesRead = input.read(buffer)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">    output.write(buffer, <span class="number">0</span>, bytesRead);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是</strong>，<code>transferTo</code> 方法可能无法传输所有的字节，即使源输入流中还有数据。这是因为 <code>transferTo</code> 方法可能在传输一定数量的字节后返回，或者在遇到 I&#x2F;O 错误时抛出异常。因此，如果你需要确保所有数据都被传输，你可能需要检查 <code>transferTo</code> 的返回值(-1)，并在必要时重复调用它，直到所有的数据都被传输。</p><p>同样的，我们也可以用用<code>FileOutputStream</code>可以从文件获取输出流，这是<code>OutputStream</code>常用的一个实现类。此外，<code>ByteArrayOutputStream</code>可以在内存中模拟一个<code>OutputStream</code>。</p><p>我们在开发过程中可能需要对流进行多种自定义操作，这样可以使用到<strong>Filter</strong>功能。</p><p>为了解决依赖继承导致子类数量失控的问题，JDK将InputStream分为提供数据基础和提供额外附加功能两大类</p><p><img src="/images/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%20ffd098987fc940b08165bbe1afeae826/Untitled%201.png" alt="Untitled"></p><p>这样，在我们使用不同功能的InputStream的时候，只需要在实例的时候包装就可以实现。无论我们包装多少次，得到的对象始终都是InputStream，直接引用就可以使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>();</span><br></pre></td></tr></table></figure><p>类似的，OutputStream也同样支持相同的操作。</p><p><img src="/images/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%20ffd098987fc940b08165bbe1afeae826/Untitled%202.png" alt="Untitled"></p><p>可以自定义Filter来实现需要的功能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readMyTest</span><span class="params">(InputStream input)</span>  <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">CountInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountInputStream</span>(input))&#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = inputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Total read &quot;</span> + inputStream.getBytesRead() + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CountInputStream(InputStream in) &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBytesRead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//计算stream中a的数量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.read();</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">97</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.read(b, off, len);</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.count += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不同服务端中的项目位置是不同的，导致无法固定配置文件的路径，使用classPath来读取文件，避免不同环境下文件路径不一致的问题。例如把default.properties文件放在classpath中，就无需关心实际存放的路径。</p><p><strong>通过序列化与反序列化可以进行数据的传输</strong></p><p>序列化的本质是把对象变成二进制数组，也就是byte[]。</p><p>把一个Java对象变为<code>byte[]</code>数组，需要使用<code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(buffer)) &#123;</span><br><span class="line">            <span class="comment">// 写入int:</span></span><br><span class="line">            output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">            output.writeUTF(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">            output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>ObjectOutputStream功能强大，既可以写入int，boolean等基本类型，也可以写入String(UTF-8)，还可以写入实现了Serializable接口的Object。</p><p>与ObjectOutputStream相反，ObjectOutputStream负责从一个字节流读取Java对象，也就是反序列化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(...)) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.readInt();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.readUTF();</span><br><span class="line">    <span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> (Double) input.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了能读取上诉类型之外，可以调用readObject()可以直接返回一个Object对象，再进行强转，该方法会抛出两个异常。</p><ul><li>ClassNotFoundException<ul><li>该情况常见与在不同终端上没有建立相同的对象，导致在接收终端无法找到对应的类。</li></ul></li><li>InvaildClassException<ul><li>这种情况常见于想序列化和反序列化中的字段类型冲突，导致class不兼容。</li></ul></li></ul><p>为了避免这种情况，Java序列化允许class定义一个特殊的serialVersionUID静态变量，用于标识Java类的序列化版本，由IDE自动生成。这样如果修改了字段，就会改变该值。</p><p><strong>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息</strong>。</p><h3 id="Reader-And-Writer"><a href="#Reader-And-Writer" class="headerlink" title="Reader And Writer"></a>Reader And Writer</h3><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取。</p><p>也就是说，在提供read()的方法中，返回的是0~65535的int类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;out/readme.txt&quot;</span>, StandardCharsets.UTF_8))&#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span>( (n = reader.read() )!= -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：FileReader带指定编码格式在Java8及以前的版本并不提供。</p><p>相对应Input流，<strong>Reader</strong>中也有对应的子类提供。</p><ul><li><p><code>CharArrayReader</code>可以在内存中模拟一个<code>Reader</code>，它的作用实际上是把一个<code>char[]</code>数组变成一个<code>Reader</code>，这和<code>ByteArrayInputStream</code>非常类似：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharArrayReader</span>(<span class="string">&quot;Hello&quot;</span>.toCharArray())) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>StringReader</code>可以直接把<code>String</code>作为数据源，它和<code>CharArrayReader</code>几乎一样。</p></li></ul><p>可以看出Reader与InputStream有着不小的关联，普通的<code>Reader</code>实际上是基于<code>InputStream</code>构造的，因为<code>Reader</code>需要从<code>InputStream</code>中读入字节流（<code>byte</code>），然后，根据编码设置，再转换为<code>char</code>就可以实现字符流。如果我们查看<code>FileReader</code>的源码，它在内部实际上持有一个<code>FileInputStream</code>。</p><p>这样，如果我们持有一个保存byte[]的InputStream，我们是否可以直接转为Reader类型。InputStreamReader就是Java提供的一个转换器，可以把任何InputStream转换为Reader</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也可以看作是一种FileReader的实现，在FileReader的源码中，可以看到其实是实现了FileInputStream。</p><p><strong>Writer与Reader类似，这里就不再进行赘述</strong>。</p><h3 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h3><p>从Java7开始，Java提供了这个工具类，极大的加快了工作速度。</p><p>Files提供的读写方法十分的方便：</p><ul><li><p>**<code>byte**[] data = Files.readAllBytes(Path.of(&quot;/path/to/file.txt&quot;));</code></p><p>  将文件的内容全部读取为byte[]</p></li><li><p><code>String content1 = Files.readString(Path.of(&quot;/path/to/file.txt&quot;));</code></p><p>  将文件内容全部读取为String，可以指定读取编码类型。</p></li><li><p>**<code>List**&lt;String&gt; lines = Files.readAllLines(Path.of(&quot;/path/to/file.txt&quot;));</code></p><p>  按行读取并返回每一行的内容</p></li><li><p><code>Files.write(Path.of(&quot;/path/to/file.txt&quot;), data);</code></p><p>  写入二进制文件</p></li><li><p><code>Files.writeString(Path.of(&quot;/path/to/file.txt&quot;), &quot;文本内容...&quot;, StandardCharsets.ISO_8859_1);</code></p><p>  根据编码类型写入文件</p></li><li><p><code>Files.write(Path.of(&quot;/path/to/file.txt&quot;), lines);</code></p><p>  按行写入文件</p></li></ul><p>此外，<code>Files</code>工具类还有<code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p><p><strong>注意</strong>：<code>Files</code>提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。</p><h3 id="BIO、NIO与AIO"><a href="#BIO、NIO与AIO" class="headerlink" title="BIO、NIO与AIO"></a><strong>BIO、NIO与AIO</strong></h3><p><img src="/images/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%20ffd098987fc940b08165bbe1afeae826/Untitled%203.png" alt="Untitled"></p><p><strong>Blocking I&#x2F;O</strong>：传统IO，同步阻塞，服务器实现模式为一个连接一个线程</p><p><img src="/images/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%20ffd098987fc940b08165bbe1afeae826/Untitled%204.png" alt="Untitled"></p><p>BIO方式适用于链接数目比较小而且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中。</p><p><strong>Java non-blocking IO</strong>，是指JDK提供的新的API。从1.4开始，提供了一系列改进的输入&#x2F;输出的新特性，被统称为NIO</p><p>NIO是<strong>同步非阻塞</strong>的，服务器端用一个线程处理多个连接，客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到链接有IO请求就进行处理。</p><p>NIO的数据在传输的时候是面向<strong>缓冲区Buffer</strong>的，必须从Buffer中读取或写入</p><p><img src="/images/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%20ffd098987fc940b08165bbe1afeae826/Untitled%205.png" alt="Untitled"></p><ul><li>每个Channel对应一个Buffer</li><li>Selector对应一个线程，一个线程对应多个Channel。</li><li>Selector会根据不同的事件，在各个通道上切换</li><li>Buffer是内存块，底层是数据</li></ul><p><strong>Asynchronous I&#x2F;O</strong>，AIO是异步不阻塞的I&#x2F;O。NIO就是reactor，当有事件触发时，服务器端得到通知，进行相应的处理，完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化就是把Java对象转换为二进制流，方便存储和传输。反序列化就是把二进制流恢复成对象。</p><p><strong>Serializable接口</strong></p><p>这个接口只是一个标记，没有具体的作用，但是如果不实现这个接口，在有些序列化的场景就会报错，所以建议创建JavaBean类都实现Serializable。</p><p><strong>serialVersionUID作用：</strong></p><p>起一个验证的作用，用来验证序列化对象和反序列化对象的ID是否一致。</p><p>对于不想序列化的变量，可以使用transient关键字修饰。</p><p><strong>transient</strong>：阻止实例中哪些用词关键字修饰的变量进行序列化。只能<strong>修饰变量</strong>。</p><p><strong>序列化的方式</strong></p><p><img src="/images/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%20ffd098987fc940b08165bbe1afeae826/Untitled%206.png" alt="Untitled"></p><ul><li>Java对象序列化：Java原生序列化方法即通过Java原生流I&#x2F;O Stream方法进行转化(上文)。</li><li>Json序列化：最常用的序列化方式，将对象转化为byte数组或者json串。</li><li>ProtoBuff 序列化：ProtocolBuffer 是一种轻便高效的结构化数据存储格式，ProtoBuff 序列化对象可以很大程度上将其压缩，可以大大减少数据传输大小，提高系统性能。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>API接口文档Swagger使用指南</title>
      <link href="/2024/04/17/API%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3Swagger%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2024/04/17/API%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3Swagger%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="API接口文档Swagger使用指南"><a href="#API接口文档Swagger使用指南" class="headerlink" title="API接口文档Swagger使用指南"></a>API接口文档Swagger使用指南</h1><p><em><strong>Swagger</strong></em>—一款致力于解决接口规范化、标准化、文档化的开源库，一款真正的开发神器。</p><p><em><strong>Swagger</strong></em>是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。Swagger是一个规范和完整的框架。用于生成、描述、调用和可视化RESTful风格的Web服务。</p><ul><li>对于后端来说<ul><li>不用手写WiKi接口手拼大量参数</li><li>对代码侵入性低，使用全注解的方式</li><li>方法参数名修改、增加、减少参数都可以直接生效，无需手动维护</li><li>缺点：增加开发成本，写接口还要再写一套参数配置。</li></ul></li><li>对于前端来说<ul><li>后端只需要定义接口就会自动生成文档，接口的参数和功能一目了然。</li><li>联调方便</li></ul></li></ul><h3 id="搭建一个Swagger"><a href="#搭建一个Swagger" class="headerlink" title="搭建一个Swagger"></a>搭建一个Swagger</h3><ul><li><p>引入Swagger的依赖</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- swagger --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-spring-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>SpringBoot整合swagger</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">productApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))  <span class="comment">//添加ApiOperiation注解的被扫描</span></span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>().title(”swagger和springBoot整合“).description(”swagger的API文档<span class="string">&quot;)</span></span><br><span class="line"><span class="string">                .version(&quot;</span><span class="number">1.0</span><span class="string">&quot;).build();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在controller上使用swagger的注解</p></li></ul><p>调用Swagger</p><p><a href="http://localhost:8093/swagger-ui.html">http://localhost:8093/swagger-ui.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇总</title>
      <link href="/2024/04/16/%E6%B1%87%E6%80%BB/"/>
      <url>/2024/04/16/%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p><a href="https://hyw20010212.github.io/2024/04/21/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/">单例设计与main()的理解</a></p><p><a href="https://hyw20010212.github.io/2024/04/21/JVM%E4%B8%8E%E6%B3%A8%E9%87%8A%20API%E6%96%87%E6%A1%A3/">JVM与注释\API文档 </a></p><p><a href="https://www.notion.so/Static-final-eb56c1e3045c4e628e7c8fad6b66a884?pvs=21">Static与final</a></p><p><a href="https://www.notion.so/interface-bb982ec267f04ca0a775c2888ba193ab?pvs=21">接口interface</a></p><p><a href="https://www.notion.so/190eb41eb44c4aafb527d7fd518d7cda?pvs=21">内部类</a></p><p><a href="https://www.notion.so/285ecb55361642f2b7461eedf4b20b38?pvs=21">小知识</a></p><p><a href="https://www.notion.so/bf18de630f1940a9a2d9326552b07a91?pvs=21">线程</a></p><p><a href="https://www.notion.so/API-7d6ae30439d44567922fdb20f9b3c201?pvs=21">常用类与基础API</a></p><p><a href="https://hyw20010212.github.io/2024/04/17/File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/">File类与IO流</a></p><p><a href="https://www.notion.so/14beb6f4e4274158940f02bc7e43704a?pvs=21">反射</a></p><p><a href="https://www.notion.so/4b5ab83e3d894ed5867501f032b2e56d?pvs=21">异步编程</a></p><p><a href="https://www.notion.so/d57eabc5f3134c4a9d4648af6b0b93b0?pvs=21">泛型</a></p><p><a href="https://www.notion.so/Lambda-b9b7b56096e34313921ea8b78b0269b8?pvs=21">Lambda表达式</a></p><p><a href="https://www.notion.so/39cab743232b4e818b34b092de978b41?pvs=21">代码块</a></p><p><a href="https://www.notion.so/API-Swagger-55adf4934a924b4b86ffffea24c675eb?pvs=21">API接口文档Swagger使用指南</a></p><p><a href="https://www.notion.so/edff3e9eeff442fe87a30c74a245e229?pvs=21">异常处理</a></p><p><a href="https://www.notion.so/Mybatis-Plus-166eb8ddf4b64a7c8563c006b5a9a9bf?pvs=21">Mybatis Plus</a></p><p><a href="https://www.notion.so/abstract-7ec07dfc0e1345f0b28eab2e00632f8f?pvs=21">抽象类与抽象方法 abstract</a></p><p><a href="https://www.notion.so/Annotation-5ae77cca62f74e0d97f4508a76bf1127?pvs=21">注解Annotation</a></p><p><a href="https://www.notion.so/8e2dbf089c7b47e7bae37d30c94dbd20?pvs=21">单元测试</a></p><p><a href="https://www.notion.so/JMM-3bf254ca6b2d45d0bdcab80f6f5e0e55?pvs=21">JMM</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
